// Skyris Dual‑Stream (ESP32‑S3 XIAO Sense) — ESP32 Native HTTP Server with Thermal Imaging
// 2025‑05‑26 ULTRA FAST VERSION - WiFi Station Mode (连接现有WiFi网络)
//
// 🔧 WiFi配置说明:
// 1. 修改下面的WIFI_SSID为你的WiFi网络名称
// 2. 修改下面的WIFI_PASS为你的WiFi密码
// 3. 确保目标WiFi网络在范围内且可连接
// 4. 编译并上传代码到ESP32
// 5. 通过Serial Monitor查看连接状态和IP地址
// 6. 使用获得的IP地址访问Web界面
//
// 📱 访问方式:
// - Web界面: http://[设备IP地址]
// - WebSocket: ws://[设备IP地址]:81
// - 设备IP地址会在Serial Monitor中显示
//
// ⚠️ 注意事项:
// - 如果WiFi连接失败，设备将以离线模式运行
// - 传感器和舵机功能不受WiFi影响
// - 可通过Serial Monitor监控所有功能状态

#include <Arduino.h>
#include <WiFi.h>

// 解决sensor_t类型冲突的终极方案：重命名ESP32摄像头的sensor_t
#define sensor_t camera_sensor_t
#include <esp_camera.h>
#include <esp_http_server.h>
#include <esp_timer.h>
#undef sensor_t

// 然后安全包含其他库和Adafruit传感器库
#include <ESP32Servo.h>
#include <Wire.h>
#include <WebSocketsServer.h>


//-------------------------------- FastLED Configuration
// #define LED_PIN     2    // 改为XIAO ESP32S3的D2引脚 (GPIO2)
// #define NUM_LEDS    2    // 使用2个LED灯珠
// #define LED_TYPE    WS2812B
// #define COLOR_ORDER GRB

// LED control variable
// enum LedMode {
//   LED_BREATH,      // 呼吸灯模式
//   LED_RAINBOW,     // 彩虹模式
//   LED_SOLID,       // 固定颜色模式
//   LED_OFF          // 关闭模式
// };

// volatile LedMode current_led_mode = LED_BREATH;
// CRGB breath_color = CRGB::White;  // 改为白色，更容易看到亮度变化
// volatile bool led_enabled = true;

// WebSocket connection status
// volatile bool websocket_connected = false;
// WebSocketsServer webSocket = WebSocketsServer(81);  // WebSocket port 81

// 呼吸灯参数 - 符合人体呼吸频率，增加亮度范围
// float breath_phase = 0.0;
// float breath_speed = 0.2;  // 快速呼吸 (约3秒一个周期，类似测试时速度)
// float breath_speed_connected = 0.15;  // WebSocket connection后稍慢 (约4秒一个周期)
// int max_brightness = 255;  // 最大亮度
// int min_brightness = 50;   // 提高最小亮度，让变化更明显

// 彩虹效果参数
// uint8_t rainbow_hue = 0;

// LED command extensions
// const char* led_commands[] = {"LED_BREATH", "LED_RAINBOW", "LED_SOLID", "LED_OFF", "LED_COLOR"};

//-------------------------------- Wi‑Fi Station Mode Configuration
#define WIFI_SSID "hupan"        // 修改为你的WiFi网络名称
#define WIFI_PASS "hupan@HYR2014525"    // 修改为你的WiFi密码
#define WIFI_TIMEOUT 30000                // WiFi connection timeout (30 seconds)

String device_ip = "";  // 存储设备IP地址

//-------------------------------- Direction Definitions (moved here to fix compilation order)
#define IDLE     0
#define FORWARD  1
#define UP       2
#define DOWN     3
#define LEFT     4
#define RIGHT    5
#define BACKWARD 6
#define LWAVE  7
#define RWAVE 8


//==================== 舵机分步状态机结构体 ====================
typedef struct {
  int direction;           // 当前动作方向
  float Ind_var;           // 当前动作进度
  float interval_tims;     // 步进间隔
  int interval_ms;         // 步进延迟（已不用）
  bool in_progress;        // 是否有动作在进行
  bool continuous;         // 是否持续运动
  unsigned long last_step_time; // 上次步进时间
} ServoMotionState;

ServoMotionState servoState = {IDLE, 0, 6, 5, false, false, 0};
//==================== End ====================


// 定高控制参数
// float targetAltitude = 1.2;          // 目标悬停高度 (米)
// float currentAltitude = 0.0;         // 当前高度 (米)
// volatile int pendingUpCompensate = 0; // 非阻塞UP补偿计数

// 定高控制状态
// bool altitudeHoldEnabled = false;    // 定高模式开关
// unsigned long lastAltitudeRead = 0;
// const unsigned long altitudeReadInterval = 50;  // 50ms读取一次高度（原100ms）

// 定高控制逻辑
// float altitudeTolerance = 0.2;       // 高度容差 (±20cm)
// unsigned long lastAltitudeControl = 0;
// const unsigned long altitudeControlInterval = 200;  // 200ms控制一次

//-------------------------------- Camera pins (XIAO‑S3 Sense OV2640)
static camera_config_t cam_cfg = {
  .pin_pwdn  = -1, .pin_reset = -1,
  .pin_xclk  = 10,
  .pin_sscb_sda = 40, .pin_sscb_scl = 39,
  .pin_d7 = 48, .pin_d6 = 11, .pin_d5 = 12, .pin_d4 = 14,
  .pin_d3 = 16, .pin_d2 = 18, .pin_d1 = 17, .pin_d0 = 15,
  .pin_vsync = 38, .pin_href = 47, .pin_pclk = 13,
  .xclk_freq_hz = 20000000,
  .ledc_timer   = LEDC_TIMER_0,
  .ledc_channel = LEDC_CHANNEL_0,
  .pixel_format = PIXFORMAT_JPEG,
  .frame_size   = FRAMESIZE_SVGA,
  .jpeg_quality = 10,
  .fb_count     = 2,
  .fb_location  = CAMERA_FB_IN_PSRAM,
  .grab_mode    = CAMERA_GRAB_WHEN_EMPTY
};

static httpd_handle_t camera_httpd = NULL;

//-------------------------------- ESP32Servo 舵机控制 (状态机版本 - 真正快速响应)
// 舵机对象 - 双翼4DOF结构 (基于Qbo原版映射)
Servo sla, slb, sra, srb;
// sla: 左翼扑动舵机 (控制左翼扑翼动作)
// slb: 左翼转向舵机 (控制左翼攻角/方向)  
// sra: 右翼扑动舵机 (控制右翼扑翼动作)
// srb: 右翼转向舵机 (控制右翼攻角/方向)

// 蓝牙命令映射 - 只保留飞行/模式相关命令
const char* cmdMap[] = {"IDLE", "FWD", "UP", "DOWN", "LEFT", "RIGHT", "BACK", "LWAVE", "RWAVE", "TRACK", "CRUISE", "MANUAL"};
const int CMD_COUNT = 12;

// 舵机参数 - MG90S
int min_angle = 0, mid_angle = 90, max_angle = 180;
const float servo_step = 5.0; // 每次最大变化5度

// 新增：舵机当前角度变量和平滑步长
float sla_current = 90, slb_current = 90, sra_current = 90, srb_current = 90;

// 平滑插值函数
float smoothMove(float current, float target, float step) {
  if (abs(target - current) <= step) return target;
  return current + (target > current ? step : -step);
}

// 状态机变量 - 使用原版本的完整循环方式
volatile int current_direction = IDLE;
volatile int target_direction = IDLE;
volatile bool direction_changed = false;
volatile bool motion_in_progress = false;
volatile bool stop_motion = false;  // 立即停止标志
volatile bool continuous_motion = false;  // 持续运动标志

// 避障控制标志
volatile bool obstacle_avoidance_active = false;  // 避障激活标志
volatile bool obstacle_override_command = false;  // 避障是否覆盖用户命令

//-------------------------------- AMG8833 Thermal Functions



//-------------------------------- Camera Functions
bool initCamera() {
  Serial.println("🔧 开始初始化摄像头...");
  esp_err_t err = esp_camera_init(&cam_cfg);
  if(err != ESP_OK) {
    Serial.printf("❌ 摄像头初始化失败: 0x%x\n", err);
      return false;
    }
  Serial.println("✅ 摄像头初始化成功");
  
  // 摄像头配置 - 使用重定义的类型
  camera_sensor_t *s = esp_camera_sensor_get();
  if (s != NULL) {
    s->set_vflip(s, 1);
    s->set_hmirror(s, 0);
    s->set_quality(s, 10);
    Serial.println("✅ 摄像头配置完成");
  }
  
  return true;
}

void readCameraFrame() {
  camera_fb_t *fb = esp_camera_fb_get();
  if (!fb) {
    Serial.println("❌ 获取摄像头帧失败");
    return;
  }
  
  // 处理摄像头帧数据
  // ...
  
  esp_camera_fb_return(fb);
  }

//-------------------------------- ESP32Servo 舵机控制 (状态机版本 - 真正快速响应)
// 舵机对象 - 双翼4DOF结构 (基于Qbo原版映射)
Servo sla, slb, sra, srb;
// sla: 左翼扑动舵机 (控制左翼扑翼动作)
// slb: 左翼转向舵机 (控制左翼攻角/方向)  
// sra: 右翼扑动舵机 (控制右翼扑翼动作)
// srb: 右翼转向舵机 (控制右翼攻角/方向)

// 舵机初始化 - 针对MG90S优化
void servo_attach() {
  Serial.println("🔧 开始初始化MG90S舵机 (状态机版本)...");
  sla.attach(3, 1000, 2000);  // MG90S推荐脉宽范围
  sla.write(mid_angle);
  Serial.println("✅ sla (引脚 3) 左翼扑动舵机初始化完成");
  slb.attach(4, 1000, 2000);
  slb.write(mid_angle);
  Serial.println("✅ slb (引脚 4) 左翼转向舵机初始化完成");
  sra.attach(7, 1000, 2000);
  sra.write(mid_angle);
  Serial.println("✅ sra (引脚 7) 右翼扑动舵机初始化完成");
  srb.attach(8, 1000, 2000);
  srb.write(mid_angle);
  Serial.println("✅ srb (引脚 8) 右翼转向舵机初始化完成");
  Serial.println("🔧 MG90S舵机初始化完成 - 超快响应模式启用");
  Serial.println("📊 舵机参数: 180°范围, 0.08~0.10s/60°, 2.0~2.5kg·cm, 金属齿轮, 推荐脉宽1000-2000us");
}

void servo_detach() {
  sla.detach();
  slb.detach();
  sra.detach();
  srb.detach();
}

// 检查字符串是否只包含合法字符
bool isValidCommand(const char* input, size_t len) {
  for (size_t i = 0; i < len; i++) {
    char c = input[i];
    // 允许字母、数字、下划线、冒号和逗号（用于LED命令）
    if (!isAlpha(c) && !isDigit(c) && c != '_' && c != ':' && c != ',') {
      return false;
    }
  }
  return true;
}

// 立即设置舵机到IDLE位置 - 超快响应版本
void setServoIdle() {
  // 平滑插值回中位
  bool all_ready = false;
  while (!all_ready) {
    all_ready = true;
    sla_current = smoothMove(sla_current, mid_angle, servo_step);
    slb_current = smoothMove(slb_current, mid_angle, servo_step);
    sra_current = smoothMove(sra_current, mid_angle, servo_step);
    srb_current = smoothMove(srb_current, mid_angle, servo_step);
    sla.write(sla_current);
    slb.write(slb_current);
    sra.write(sra_current);
    srb.write(srb_current);
    if (sla_current != mid_angle || slb_current != mid_angle ||
        sra_current != mid_angle || srb_current != mid_angle) {
      all_ready = false;
    }
    vTaskDelay(10 / portTICK_PERIOD_MS); // 和其他动作一致
  }
  Serial.println("🛑 舵机平滑回中位完成");
}

// 强制立即停止所有动作
void forceStopMotion() {
  stop_motion = true;
  motion_in_progress = false;
  continuous_motion = false;  // 停止持续运动
  current_direction = IDLE;
  target_direction = IDLE;
  direction_changed = false;
  setServoIdle();
  Serial.println("⚡ 强制立即停止所有动作");
}


//-------------------------------- HTTP Server Functions - TEMPORARILY DISABLED
/*
static esp_err_t index_handler(httpd_req_t *req) {
  const char* html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skyris WebSocket Control</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f0f0f0; }
        .container { max-width: 1200px; margin: 0 auto; }
        .panel { background: white; border-radius: 10px; padding: 20px; margin: 10px 0; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-width: 300px; margin: 0 auto; }
        .btn { padding: 15px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; transition: all 0.3s; }
        .btn:hover { transform: scale(1.05); }
        .flight-btn { background: #4CAF50; color: white; }
        .flight-btn:hover { background: #45a049; }
        .led-btn { background: #2196F3; color: white; margin: 5px; }
        .led-btn:hover { background: #1976D2; }
        .status { padding: 10px; border-radius: 5px; margin: 10px 0; }
        .connected { background: #d4edda; color: #155724; }
        .disconnected { background: #f8d7da; color: #721c24; }
        .thermal-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px; max-width: 400px; margin: 20px auto; }
        .thermal-cell { width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 10px; border-radius: 3px; }
        .color-picker { margin: 10px; }
        .preset-colors { display: flex; gap: 10px; margin: 10px 0; }
        .color-preset { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 2px solid #ccc; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🚁 Skyris WebSocket Control</h1>
        
        <div class="panel">
            <h2>🔌 Connection Status</h2>
            <div id="status" class="status disconnected">Disconnected</div>
        </div>
        
        <div class="panel">
            <h2>🎮 Flight Control</h2>
            <div class="grid">
                <div></div>
                <button class="btn flight-btn" onclick="sendCommand('UP')">⬆️ UP</button>
                <div></div>
                <button class="btn flight-btn" onclick="sendCommand('LEFT')">⬅️ LEFT</button>
                <button class="btn flight-btn" onclick="sendCommand('IDLE')" style="background: #f44336;">🛑 STOP</button>
                <button class="btn flight-btn" onclick="sendCommand('RIGHT')">➡️ RIGHT</button>
                <button class="btn flight-btn" onclick="sendCommand('BACK')">⬇️ BACK</button>
                <button class="btn flight-btn" onclick="sendCommand('DOWN')">⬇️ DOWN</button>
                <button class="btn flight-btn" onclick="sendCommand('FWD')">⬆️ FWD</button>
            </div>
        </div>
        
        <div class="panel">
            <h2>🎯 Flight Mode</h2>
            <div>
                <button class="btn led-btn" onclick="sendCommand('MANUAL')" style="background: #FF9800;">🎮 Manual</button>
                <button class="btn led-btn" onclick="sendCommand('TRACK')" style="background: #E91E63;">🔥 Track</button>
                <button class="btn led-btn" onclick="sendCommand('CRUISE')" style="background: #9C27B0;">🎲 Cruise</button>
                <button class="btn led-btn" onclick="sendCommand('ALTITUDE')" style="background: #4CAF50;">📏 Altitude Hold</button>
            </div>
            <div id="currentMode" style="margin-top: 10px; font-weight: bold;">Current Mode: Manual</div>
            <div style="margin: 10px 0; padding: 10px; background: #e8f5e8; border-radius: 5px; font-size: 14px;">
                📏 <strong>定高模式:</strong> 自动保持1.5米以上悬停高度，与其他模式兼容
            </div>
            <div style="margin-top: 10px;">
                <button class="btn led-btn" onclick="resetBMP388L()" style="background: #FF5722;">🔧 重置BMP388L</button>
                <div id="bmp388Status" style="margin-top: 5px; font-size: 12px; color: #666;">点击重置按钮可解决气压计数据卡死问题</div>
            </div>
        </div>
        
        <div class="panel">
            <h2>🌈 LED Control</h2>
            <div>
                <button class="btn led-btn" onclick="sendCommand('LED_BREATH')">🫁 Breathing</button>
                <button class="btn led-btn" onclick="sendCommand('LED_RAINBOW')">🌈 Rainbow</button>
                <button class="btn led-btn" onclick="sendCommand('LED_SOLID')">💡 Solid</button>
                <button class="btn led-btn" onclick="sendCommand('LED_OFF')">⚫ Off</button>
            </div>
            <div style="margin: 10px 0; padding: 10px; background: #e8f5e8; border-radius: 5px; font-size: 14px;">
                💡 <strong>提示:</strong> 呼吸灯模式使用当前选择的颜色，建议使用较亮的颜色以获得最佳效果
            </div>
            <div class="color-picker">
                <label>Custom Color: </label>
                <input type="color" id="colorPicker" value="#ffffff" onchange="updateColor()">
            </div>
            <div class="preset-colors">
                <div class="color-preset" style="background: red;" onclick="setPresetColor(255,0,0)"></div>
                <div class="color-preset" style="background: green;" onclick="setPresetColor(0,255,0)"></div>
                <div class="color-preset" style="background: blue;" onclick="setPresetColor(0,0,255)"></div>
                <div class="color-preset" style="background: yellow;" onclick="setPresetColor(255,255,0)"></div>
                <div class="color-preset" style="background: purple;" onclick="setPresetColor(255,0,255)"></div>
                <div class="color-preset" style="background: cyan;" onclick="setPresetColor(0,255,255)"></div>
                <div class="color-preset" style="background: white;" onclick="setPresetColor(255,255,255)"></div>
            </div>
        </div>
        
        <div class="panel">
            <h2>🔥 Thermal Imaging</h2>
            <div id="thermalGrid" class="thermal-grid"></div>
        </div>
        
        <div class="panel">
            <h2>📹 Camera Stream</h2>
            <img src="/stream" style="max-width: 100%; border-radius: 10px;">
        </div>
    </div>

    <script>
        let ws;
        let wsConnected = false;
        
        function connectWebSocket() {
            ws = new WebSocket('ws://' + window.location.hostname + ':81');
            
            ws.onopen = function() {
                wsConnected = true;
                document.getElementById('status').className = 'status connected';
                document.getElementById('status').textContent = 'Connected to WebSocket';
                console.log('WebSocket connected');
                
                // 请求当前避障状态（通过发送状态查询命令）
                setTimeout(() => {
                    console.log('Requesting initial obstacle avoidance status...');
                    // 发送一个状态查询命令，ESP32会在下次热成像数据中包含状态
                }, 1000);
            };
            
            
            ws.onclose = function() {
                wsConnected = false;
                document.getElementById('status').className = 'status disconnected';
                document.getElementById('status').textContent = 'Disconnected - Reconnecting...';
                console.log('WebSocket disconnected');
                setTimeout(connectWebSocket, 3000);
            };
            
            ws.onmessage = function(event) {
                console.log('Received:', event.data);
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'thermal') {
                        console.log('WebSocket thermal data received:', data.pixels.length, 'pixels');
                        updateThermalGrid(data.pixels);
                        // 更新避障状态（如果包含在热成像数据中）
                        if (data.avoidance_active !== undefined) {
                            updateObstacleStatus({
                                avoidance_active: data.avoidance_active,
                                distance: data.tof_distance,
                                sensor_available: data.tof_available
                            });
                        }
                    } else if (data.type === 'mode') {
                        document.getElementById('currentMode').textContent = 'Current Mode: ' + data.mode;
                    } else if (data.type === 'status') {
                        console.log('Status update:', data);
                    } else if (data.type === 'response') {
                        console.log('Command response:', data);
                        // 处理BMP388L重置响应
                        if (data.command === 'RESET_BMP388L') {
                            const statusDiv = document.getElementById('bmp388Status');
                            if (data.status === 'success') {
                                statusDiv.textContent = '✅ BMP388L重置成功！';
                                statusDiv.style.color = '#4CAF50';
                                setTimeout(() => {
                                    statusDiv.textContent = '点击重置按钮可解决气压计数据卡死问题';
                                    statusDiv.style.color = '#666';
                                }, 3000);
    } else {
                                statusDiv.textContent = '❌ BMP388L重置失败，请重试';
                                statusDiv.style.color = '#f44336';
                                setTimeout(() => {
                                    statusDiv.textContent = '点击重置按钮可解决气压计数据卡死问题';
                                    statusDiv.style.color = '#666';
                                }, 3000);
                            }
                        }
                    }
                } catch (e) {
                    console.log('Non-JSON message:', event.data);
                }
            };
            
            ws.onerror = function(error) {
                console.log('WebSocket error:', error);
            };
        }
        
        function sendCommand(command) {
            if (wsConnected && ws.readyState === WebSocket.OPEN) {
                ws.send(command);
                console.log('Sent command:', command);
      } else {
                console.log('WebSocket not connected');
            }
        }
        
        function resetBMP388L() {
            if (wsConnected && ws.readyState === WebSocket.OPEN) {
                const statusDiv = document.getElementById('bmp388Status');
                statusDiv.textContent = '🔄 正在resetBMP388L...';
                statusDiv.style.color = '#FF9800';
                
                ws.send('RESET_BMP388L');
                console.log('Sent BMP388L reset command');
            } else {
                alert('WebSocket未连接，无法执行重置操作');
            }
        }
        
        function updateColor() {
            const color = document.getElementById('colorPicker').value;
            const r = parseInt(color.substr(1, 2), 16);
            const g = parseInt(color.substr(3, 2), 16);
            const b = parseInt(color.substr(5, 2), 16);
            sendCommand(`LED_COLOR:${r},${g},${b}`);
        }
        
        function setPresetColor(r, g, b) {
            sendCommand(`LED_COLOR:${r},${g},${b}`);
            const hex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            document.getElementById('colorPicker').value = hex;
        }
        
        function updateThermalGrid(pixels) {
            const grid = document.getElementById('thermalGrid');
            grid.innerHTML = '';
            
            for (let i = 0; i < 64; i++) {
                const cell = document.createElement('div');
                cell.className = 'thermal-cell';
                const temp = pixels[i];
                cell.textContent = temp.toFixed(1);
                
                // Color coding based on temperature
                if (temp > 30) cell.style.background = '#ff4444';
                else if (temp > 25) cell.style.background = '#ffaa44';
                else if (temp > 20) cell.style.background = '#ffff44';
                else cell.style.background = '#4444ff';
                
                grid.appendChild(cell);
            }
        }
        
        // Initialize thermal grid
        for (let i = 0; i < 64; i++) {
            const cell = document.createElement('div');
            cell.className = 'thermal-cell';
            cell.textContent = '20.0';
            cell.style.background = '#4444ff';
            document.getElementById('thermalGrid').appendChild(cell);
        }
        
        // Connect on page load
        connectWebSocket();
        
        // Update thermal data every 5 seconds as backup (WebSocket is primary)
        setInterval(() => {
            // Only use HTTP as backup if WebSocket is not connected
            if (!wsConnected) {
                console.log('WebSocket disconnected, fetching thermal data via HTTP...');
                fetch('/thermal')
                    .then(response => {
                        console.log('Thermal response status:', response.status);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log('HTTP thermal data received:', data);
                        updateThermalGrid(data.pixels);
                    })
                    .catch(error => {
                        console.error('Thermal data fetch error:', error);
                    });
            }
        }, 5000);
    </script>
</body>
</html>
)rawliteral";
  
  httpd_resp_set_type(req, "text/html");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  return httpd_resp_send(req, html, strlen(html));
}

static esp_err_t thermal_handler(httpd_req_t *req) {
  Serial.println("🔥🔥🔥 收到热成像数据请求 🔥🔥🔥");
  Serial.printf("📍 请求URI: %s\n", req->uri);
  Serial.printf("📍 请求方法: %d\n", req->method);
  
  if (!thermal_sensor_available) {
    Serial.println("❌ 热成像传感器不可用");
    httpd_resp_send_404(req);
    return ESP_FAIL;
  }
  
  Serial.println("📊 开始读取热成像数据...");
  readThermalData();
  
  String json = "{\"pixels\":[";
  for (int i = 0; i < AMG88xx_PIXEL_ARRAY_SIZE; i++) {
    if (i > 0) json += ",";
    json += String(thermal_pixels[i], 1);
  }
  json += "],\"max_temp\":" + String(max_temp, 1);
  json += ",\"heat_x\":" + String(heat_source_x);
  json += ",\"heat_y\":" + String(heat_source_y) + "}";
  
  Serial.printf("📤 发送热成像JSON长度: %d\n", json.length());
  Serial.printf("📤 JSON前100字符: %s\n", json.substring(0, 100).c_str());
  
  httpd_resp_set_type(req, "application/json");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  esp_err_t result = httpd_resp_send(req, json.c_str(), json.length());
  
  if (result == ESP_OK) {
    Serial.println("✅ 热成像数据发送成功");
  } else {
    Serial.printf("❌ 热成像数据发送失败: %d\n", result);
  }
  
  return result;
}

static esp_err_t mode_handler(httpd_req_t *req) {
  size_t buf_len = httpd_req_get_url_query_len(req) + 1;
  if (buf_len > 1) {
    char* buf = (char*)malloc(buf_len);
    if (httpd_req_get_url_query_str(req, buf, buf_len) == ESP_OK) {
      char param[32];
      if (httpd_query_key_value(buf, "mode", param, sizeof(param)) == ESP_OK) {
        String mode = String(param);
        mode.toUpperCase();
        processCommand(mode);
      }
    }
    free(buf);
  }
  
  httpd_resp_set_type(req, "text/plain");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  return httpd_resp_send(req, "OK", 2);
}

static esp_err_t capture_handler(httpd_req_t *req) {
  camera_fb_t *fb = esp_camera_fb_get();
  if (!fb) {
    httpd_resp_send_500(req);
    return ESP_FAIL;
  }
  
  httpd_resp_set_type(req, "image/jpeg");
  httpd_resp_set_hdr(req, "Content-Disposition", "inline; filename=capture.jpg");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  
  esp_err_t res = httpd_resp_send(req, (const char *)fb->buf, fb->len);
  esp_camera_fb_return(fb);
  
  return res;
}

#define PART_BOUNDARY "123456789000000000000987654321"
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" PART_BOUNDARY;
static const char* _STREAM_BOUNDARY = "\r\n--" PART_BOUNDARY "\r\n";
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

static esp_err_t stream_handler(httpd_req_t *req) {
  Serial.println("📹 收到视频流请求");
  
  camera_fb_t *fb = NULL;
  esp_err_t res = ESP_OK;
  char part_buf[128];
  
  res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if (res != ESP_OK) {
    Serial.printf("❌ 设置响应类型失败: %d\n", res);
    return res;
  }
  
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  httpd_resp_set_hdr(req, "Cache-Control", "no-cache, no-store, must-revalidate");
  httpd_resp_set_hdr(req, "Pragma", "no-cache");
  httpd_resp_set_hdr(req, "Expires", "0");
  Serial.println("✅ 视频流响应头设置完成");
  
  int frame_count = 0;
  unsigned long last_frame_time = millis();
  
  while (true) {
    unsigned long frame_start = millis();
    
    fb = esp_camera_fb_get();
    if (!fb) {
      Serial.printf("❌ 获取摄像头帧失败 (帧#%d)\n", frame_count);
      res = ESP_FAIL;
      break;
    }
    
    // 减少调试输出频率，避免影响性能
    if (frame_count % 100 == 0) {  // 每100帧输出一次调试信息
      unsigned long fps = 1000 / (millis() - last_frame_time + 1);
      Serial.printf("📹 视频流正常 - 帧#%d, 大小=%d bytes, FPS≈%lu\n", frame_count, fb->len, fps);
      last_frame_time = millis();
    }
    
    // 发送边界
    if (res == ESP_OK) {
      res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    }
    
    // 发送头部
    if (res == ESP_OK) {
      size_t hlen = snprintf(part_buf, 128, _STREAM_PART, fb->len);
      res = httpd_resp_send_chunk(req, part_buf, hlen);
    }
    
    // 发送图像数据
    if (res == ESP_OK) {
      res = httpd_resp_send_chunk(req, (const char *)fb->buf, fb->len);
    }
    
    esp_camera_fb_return(fb);
    
    if (res != ESP_OK) {
      Serial.printf("❌ 视频流发送失败: %d (帧#%d)\n", res, frame_count);
      break;
    }
    
    frame_count++;
    
    // 动态帧率控制 - 根据处理时间调整延迟
    unsigned long frame_time = millis() - frame_start;
    if (frame_time < 66) {  // 目标15FPS (66ms per frame)
      vTaskDelay(pdMS_TO_TICKS(66 - frame_time));
    } else {
      vTaskDelay(pdMS_TO_TICKS(10));  // 最小延迟，避免阻塞其他任务
    }
  }
  
  Serial.printf("📹 视频流结束 - 总帧数: %d\n", frame_count);
  return res;
}
*/

//-------------------------------- WiFi Station Mode Functions
bool connectWiFi() {
  Serial.println("🔌 开始连接WiFi网络...");
  Serial.printf("📡 目标网络: %s\n", WIFI_SSID);
  
  // 设置WiFi为Station模式
  WiFi.mode(WIFI_STA);
  WiFi.disconnect(true);  // 清除之前的连接
  delay(1000);
  
  // 开始连接
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  
  unsigned long startTime = millis();
  int dots = 0;
  
  Serial.print("🔄 连接中");
  
  // 等待连接，显示进度
  while (WiFi.status() != WL_CONNECTED && (millis() - startTime) < WIFI_TIMEOUT) {
    delay(500);
    Serial.print(".");
    dots++;
    
    // 每10个点换行
    if (dots % 10 == 0) {
      Serial.printf(" (%lu秒)\n🔄 继续连接", (millis() - startTime) / 1000);
    }
    
    // 每5秒显示连接状态
    if (dots % 10 == 0) {
      switch (WiFi.status()) {
        case WL_IDLE_STATUS:
          Serial.print(" [空闲]");
          break;
        case WL_NO_SSID_AVAIL:
          Serial.print(" [网络不可用]");
          break;
        case WL_SCAN_COMPLETED:
          Serial.print(" [扫描完成]");
          break;
        case WL_CONNECT_FAILED:
          Serial.print(" [连接失败]");
          break;
        case WL_CONNECTION_LOST:
          Serial.print(" [连接丢失]");
          break;
        case WL_DISCONNECTED:
          Serial.print(" [已断开]");
          break;
        default:
          Serial.printf(" [状态:%d]", WiFi.status());
          break;
      }
    }
  }
  
  Serial.println(); // 换行
  
  if (WiFi.status() == WL_CONNECTED) {
    device_ip = WiFi.localIP().toString();
    Serial.println("✅ WiFi连接成功!");
    Serial.printf("📍 本地IP地址: %s\n", device_ip.c_str());
    Serial.printf("📶 信号强度: %d dBm\n", WiFi.RSSI());
    Serial.printf("🌐 网关: %s\n", WiFi.gatewayIP().toString().c_str());
    Serial.printf("🌐 子网掩码: %s\n", WiFi.subnetMask().toString().c_str());
    Serial.printf("🌐 DNS: %s\n", WiFi.dnsIP().toString().c_str());
    
    return true;
  } else {
    Serial.println("❌ WiFi连接失败!");
    Serial.printf("⏰ 连接超时 (%lu秒)\n", WIFI_TIMEOUT / 1000);
    
    // 显示详细的失败原因
    switch (WiFi.status()) {
      case WL_NO_SSID_AVAIL:
        Serial.printf("📡 错误: 找不到网络 '%s'\n", WIFI_SSID);
        Serial.println("💡 请检查:");
        Serial.println("   - SSID是否正确");
        Serial.println("   - 路由器是否开启");
        Serial.println("   - 距离是否过远");
        break;
      case WL_CONNECT_FAILED:
        Serial.println("🔐 错误: 连接失败");
        Serial.println("💡 请检查:");
        Serial.println("   - WiFi密码是否正确");
        Serial.println("   - 网络是否允许新设备连接");
        break;
      case WL_CONNECTION_LOST:
        Serial.println("📶 错误: 连接丢失");
        Serial.println("💡 信号可能不稳定");
        break;
      default:
        Serial.printf("❓ 未知错误 (状态码: %d)\n", WiFi.status());
        break;
    }
    
    return false;
  }
}

void checkWiFiConnection() {
  static unsigned long lastCheck = 0;
  static bool was_connected = false;
  
  // 每30秒检查一次连接状态
  if (millis() - lastCheck > 30000) {
    bool is_connected = (WiFi.status() == WL_CONNECTED);
    
    if (is_connected && !was_connected) {
      // 重新连接成功
      device_ip = WiFi.localIP().toString();
      Serial.println("🔄 WiFi重新连接成功!");
      Serial.printf("📍 IP地址: %s\n", device_ip.c_str());
    } else if (!is_connected && was_connected) {
      // 连接丢失
      Serial.println("⚠️ WiFi连接丢失，尝试重连...");
      
      // 尝试重连
      WiFi.disconnect();
      delay(1000);
      WiFi.begin(WIFI_SSID, WIFI_PASS);
      
      // 等待重连（较短超时）
      unsigned long reconnect_start = millis();
      while (WiFi.status() != WL_CONNECTED && (millis() - reconnect_start) < 10000) {
        delay(500);
        Serial.print(".");
      }
      
      if (WiFi.status() == WL_CONNECTED) {
        device_ip = WiFi.localIP().toString();
        Serial.println("\n✅ WiFi重连成功!");
        Serial.printf("📍 新IP地址: %s\n", device_ip.c_str());
      } else {
        Serial.println("\n❌ WiFi重连失败");
        device_ip = "";
      }
    } else if (is_connected) {
      // 连接正常，定期报告信号强度
      static int report_count = 0;
      if (++report_count >= 10) {  // 每5分钟报告一次
        Serial.printf("📶 WiFi连接正常 - IP: %s, 信号: %d dBm\n", 
                      device_ip.c_str(), WiFi.RSSI());
        report_count = 0;
      }
    }
    
    was_connected = is_connected;
    lastCheck = millis();
  }
}

void startWiFiStation() {
  Serial.println("🌐 启动WiFi Station模式...");
  Serial.printf("📝 配置信息:\n");
  Serial.printf("   SSID: %s\n", WIFI_SSID);
  Serial.printf("   密码: %s\n", strlen(WIFI_PASS) > 0 ? "已设置" : "未设置");
  Serial.printf("   超时: %d秒\n", WIFI_TIMEOUT / 1000);
  
  if (connectWiFi()) {
    Serial.println("🎉 WiFi Station模式启动成功!");
  } else {
    Serial.println("💥 WiFi Station模式启动失败!");
    Serial.println("📱 设备将继续以离线模式运行");
    Serial.println("🔧 请检查WiFi配置并重启设备");
  }
}

//-------------------------------- WebSocket Functions
void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
  switch(type) {
    case WStype_DISCONNECTED:
      Serial.printf("🔌 WebSocket客户端 %u 断开连接\n", num);
      websocket_connected = false;
      break;
      
    case WStype_CONNECTED:
      {
        IPAddress ip = webSocket.remoteIP(num);
        Serial.printf("🔌 WebSocket客户端 %u 连接: %s\n", num, ip.toString().c_str());
        websocket_connected = true;
        
        // 发送初始状态
        String status = "{\"type\":\"status\",\"connected\":true}";
        webSocket.sendTXT(num, status);
      }
      break;
      
    case WStype_TEXT:
      {
        String command = String((char*)payload);
        Serial.printf("📨 WebSocket收到命令: %s\n", command.c_str());
        processCommand(command);
        
        // 发送确认
        String response = "{\"type\":\"response\",\"command\":\"" + command + "\",\"status\":\"ok\"}";
        webSocket.sendTXT(num, response);
      }
      break;
      
    default:
      break;
  }
}

void initWebSocket() {
  webSocket.begin();
  webSocket.onEvent(webSocketEvent);
  Serial.println("✅ WebSocket服务器启动 (端口81)");
}

void processCommand(String command) {
  command.trim();
  command.toUpperCase();
  Serial.printf("🎮 处理命令: %s\n", command.c_str());
  // 查找命令索引
  int cmd_index = -1;
  for (int i = 0; i < CMD_COUNT; i++) {
    if (command.equals(cmdMap[i])) {
      cmd_index = i;
      break;
    }
  }
  if (cmd_index == -1) {
    Serial.printf("❌ 未知命令: %s\n", command.c_str());
    return;
  }
  // 处理不同类型的命令
  if (cmd_index >= 0 && cmd_index <= 8) {
    // 飞行控制命令
    if (cmd_index == IDLE) {
      forceStopMotion();
    } else {
      target_direction = cmd_index;
      direction_changed = true;
      continuous_motion = true;
      Serial.printf("⚡ 设置飞行方向: %s (持续运动)\n", cmdMap[cmd_index]);
    }
  } else if (cmd_index >= 9 && cmd_index <= 11) {
    // 飞行模式命令
    if (cmd_index == 9) flight_mode = TRACK_MODE;      // TRACK
    else if (cmd_index == 10) flight_mode = CRUISE_MODE; // CRUISE
    else if (cmd_index == 11) flight_mode = MANUAL_MODE; // MANUAL
    const char* mode_names[] = {"手动", "追踪", "巡航"};
    Serial.printf("🎯 飞行模式切换: %s\n", mode_names[flight_mode]);
    // 发送模式状态到WebSocket客户端
    String mode_response = "{\"type\":\"mode\",\"mode\":\"" + String(mode_names[flight_mode]) + "\"}";
    webSocket.broadcastTXT(mode_response);
  }
}

//-------------------------------- Arduino entry
void setup(){
  Serial.begin(115200);
  delay(500);
  Serial.println("⚡ 启动Skyris WiFi Station版本...");
  
  // 检查PSRAM
  if (!psramFound()) {
    Serial.println("⚠️ 未检测到PSRAM - 使用DRAM模式");
    cam_cfg.fb_location = CAMERA_FB_IN_DRAM;
    cam_cfg.frame_size = FRAMESIZE_VGA;
    cam_cfg.jpeg_quality = 15;
  }
  
  // 连接WiFi (Station模式)
  startWiFiStation();
  delay(200);
  
  // 只有在WiFi连接成功后才继续初始化服务器
  if (WiFi.status() == WL_CONNECTED) {
    // 初始化摄像头
    esp_err_t err = esp_camera_init(&cam_cfg);
    if(err != ESP_OK) {
      Serial.printf("❌ 摄像头初始化失败: 0x%x\n", err);
      return;
    }
    Serial.println("✅ 摄像头初始化成功");
    
    // 摄像头配置 - 使用重定义的类型
    camera_sensor_t *s = esp_camera_sensor_get();
    if (s != NULL) {
      s->set_vflip(s, 1);
      s->set_hmirror(s, 0);
      s->set_quality(s, 10);
      Serial.println("✅ 摄像头配置完成");
    }
    
    // 启动HTTP服务器
    startCameraServer();
    delay(100);
    
    // 初始化WebSocket
    initWebSocket();
    delay(100);
  } else {
    Serial.println("⚠️ WiFi未连接，跳过网络服务初始化");
  }
  
  
  initToFSensor();
  delay(100);
  
  
  // 初始化FastLED系统
  initLED();
  delay(100);
  
  // 设置舵机
  servo_attach();
  delay(100);
  
  // 舵机测试 - 基于fly(2).ino的测试
  Serial.println("🧪 开始基于fly(2).ino的舵机测试...");
  for(int i = 0; i < 3; i++) {
    sla.write(min_angle);
    slb.write(min_angle);
    sra.write(min_angle);
    srb.write(min_angle);
    delay(200);  // 基于fly(2).ino的测试延迟
    
    sla.write(max_angle);
    slb.write(max_angle);
    sra.write(max_angle);
    srb.write(max_angle);
    delay(200);  // 基于fly(2).ino的测试延迟
  }
  
  // 测试fly(2).ino风格的扑翼动作
  Serial.println("🧪 测试fly(2).ino风格扑翼动作...");
  for(float angle = 0; angle <= 180; angle += 10) {
    float angleL = 30 * sin(angle * PI / 180) + 90;
    float angleR = 30 * sin(angle * PI / 180 + PI) + 90;
    sla.write(angleL);
    sra.write(angleR);
    delay(50);  // 利用超快响应特性
  }
  
  // 回到中位
  sla.write(mid_angle);
  slb.write(mid_angle);
  sra.write(mid_angle);
  srb.write(mid_angle);
  Serial.println("✅ 舵机测试完成");
  
  Serial.println("🎉 Skyris WiFi Station版本启动完成!");
  Serial.printf("📊 可用内存: %d bytes\n", ESP.getFreeHeap());
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.printf("🌐 Web界面: http://%s\n", device_ip.c_str());
    Serial.printf("🔌 WebSocket: ws://%s:81\n", device_ip.c_str());
    Serial.println("📱 现在可以通过浏览器访问控制界面");
  } else {
    Serial.println("⚠️ WiFi未连接，设备以离线模式运行");
    Serial.println("🔧 修改代码中的WIFI_SSID和WIFI_PASS后重启");
  }
  
  Serial.println("\n⚡ 功能状态:");
  Serial.printf("- WiFi连接: %s\n", WiFi.status() == WL_CONNECTED ? "已连接" : "未连接");
  Serial.printf("- VL53L1X避障: %s\n", tof_sensor_available ? "已连接" : "未连接");
  Serial.println("- LED控制: 已启用");
  Serial.println("- 舵机控制: 已启用");
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n⚡ WiFi Station模式功能:");
    Serial.println("- 连接到现有WiFi网络");
    Serial.println("- 自动获取IP地址");
    Serial.println("- 支持自动重连");
    Serial.println("- 实时信号强度监测");
    Serial.println("- 热源追踪: 28°C阈值");
    Serial.println("- 飞行模式: 手动/追踪/巡航");
    Serial.println("- I2C配置: SDA=GPIO5, SCL=GPIO6");
    Serial.println("\n📏 定高控制功能:");
    Serial.printf("- 目标悬停高度: %.1f米\n", targetAltitude);
    Serial.println("- 安全保护: 最低1.5米");
    Serial.println("- 模式兼容: 与追踪/巡航模式共存");
    Serial.println("- 自动校准: 首次启用时校准起飞点");
    Serial.println("\n🚨 前向避障功能:");
    Serial.printf("- VL53L1X ToF传感器: %s\n", tof_sensor_available ? "已连接" : "未连接");
    Serial.printf("- 障碍物阈值: %.1fcm\n", obstacleThreshold);
    Serial.printf("- 警告阈值: %.1fcm\n", warningThreshold);
    Serial.printf("- 避障状态: %s\n", obstacle_avoidance_active ? "启用" : "禁用");
    Serial.println("- 避障策略: 停止->左右转向->恢复前进");
    Serial.println("- 优先级: 最高 (覆盖所有其他控制)");
    Serial.println("\n🔧 基于fly(2).ino的舵机配置:");
    Serial.println("- 角度范围: 180° (800-2100us)");
    Serial.println("- 引脚配置: sla=7, slb=8, sra=3, srb=4");
    Serial.println("- 扑翼幅度: 90度 (更大幅度)");
    Serial.println("- 延迟时间: 5ms (基于fly(2).ino)");
    Serial.println("- 双翼4DOF结构：转向+扑动分离控制");
    Serial.println("\n🎮 WebSocket命令:");
    Serial.println("- 飞行: IDLE, FWD, UP, DOWN, LEFT, RIGHT, BACK");
    Serial.println("- 模式: MANUAL, TRACK, CRUISE, ALTITUDE");
    Serial.println("- LED控制: LED_BREATH, LED_RAINBOW, LED_SOLID, LED_OFF");
    Serial.println("- LED颜色: LED_COLOR:R,G,B (例如: LED_COLOR:255,0,0)");
    Serial.println("- 避障控制: TOF_ENABLE, TOF_DISABLE");
    Serial.println("- 避障阈值: TOF_THRESHOLD:距离厘米 (例如: TOF_THRESHOLD:40)");
    Serial.println("\n🌈 FastLED功能:");
    Serial.printf("- LED引脚: D2 (GPIO%d)\n", LED_PIN);
    Serial.printf("- LED数量: %d个WS2812B\n", NUM_LEDS);
    Serial.println("- 呼吸灯: 符合人体呼吸频率 (12-20次/分钟)");
    Serial.println("- 彩虹模式: 动态色彩循环");
    Serial.println("- 固定颜色: 可通过WebSocket自定义RGB颜色");
  } else {
    Serial.println("\n❌ 网络功能离线:");
    Serial.println("- 修改代码顶部的WIFI_SSID和WIFI_PASS");
    Serial.println("- 确保目标WiFi网络可用");
    Serial.println("- 重新编译并上传代码");
    Serial.println("- 传感器和舵机功能正常工作");
  }
  
  //==================== 新增多任务注册 ====================
  xTaskCreatePinnedToCore(ToFTask, "ToFTask", 4096, nullptr, 4, nullptr, 1);
  xTaskCreatePinnedToCore(ServoTask, "ServoTask", 4096, nullptr, 5, nullptr, 1);
  xTaskCreatePinnedToCore(LEDTask, "LEDTask", 4096, nullptr, 2, nullptr, 1);
  xTaskCreatePinnedToCore(FlightControlTask, "FlightControlTask", 4096, nullptr, 3, nullptr, 1);
  //==================== End ====================

   Serial.printf("📊 剩余内存: %d bytes\n", ESP.getFreeHeap());
}

void loop(){ 
  webSocket.loop();

  // ====== 新增：定期推送状态到WebSocket客户端 ======
  static unsigned long lastStatusPush = 0;
  if (millis() - lastStatusPush > 1000) { // 每1秒推送一次
    String status = "{";
    status += "\"type\":\"status\",";
    status += "\"altitude\":" + String(currentAltitude, 2) + ",";
    status += "\"altitude_hold_enabled\":" + String(altitudeHoldEnabled ? "true" : "false") + ",";
    status += "\"avoidance_active\":" + String(obstacle_avoidance_active ? "true" : "false") + ",";
    status += "\"tof_distance\":" + String(tof_distance_cm, 1) + ",";
    status += "\"obstacle_detected\":" + String(obstacleDetected ? "true" : "false") + ",";
    status += "\"main_mode\":\"";
    status += (flight_mode == CRUISE_MODE ? "CRUISE" : "MANUAL");
    status += "\"";
    status += "}";
    webSocket.broadcastTXT(status);
    lastStatusPush = millis();
  }

  

  static unsigned long lastReport = 0;
  static unsigned long lastThermalTest = 0;
  
  // 检查WiFi连接状态
  checkWiFiConnection();
  
  // 每60秒报告一次状态 (从30秒增加到60秒)
  if(millis() - lastReport > 60000) {
    const char* mode_names[] = {"手动", "追踪", "巡航", "定高"};
    Serial.printf("⚡ 系统运行中 | WiFi: %s | 内存: %d bytes | 方向: %s | 模式: %s\n", 
                  WiFi.status() == WL_CONNECTED ? "已连接" : "未连接",
                  ESP.getFreeHeap(), 
                  cmdMap[current_direction], 
                  mode_names[flight_mode]);
    
    if (WiFi.status() == WL_CONNECTED) {
      Serial.printf("📍 设备IP: %s | 信号强度: %d dBm\n", device_ip.c_str(), WiFi.RSSI());
    }
    
    
    
    if (tof_sensor_available) {
      const char* obs_state_names[] = {"无障碍", "警告", "左避障", "右避障", "阻挡"};
      Serial.printf("🚨 避障状态: 距离=%.1fcm, 状态=%s, 激活=%s\n", 
                    tof_distance_cm, 
                    obs_state_names[obstacle_state],
                    obstacle_avoidance_active ? "是" : "否");
    }
    
    lastReport = millis();
  }
  
  // 每30秒强制测试热成像传感器 (从10秒增加到30秒)
  if(millis() - lastThermalTest > 30000) {
    
    // 测试避障传感器
    if (tof_sensor_available && obstacle_avoidance_active) {
      Serial.println("\n🚨 ===== 强制避障测试 =====");
      readToFData();
      
      Serial.printf("📏 ToF距离: %.1fcm (状态: %d)\n", tof_distance_cm, tof_range_status);
      Serial.printf("🚨 障碍检测: %s (阈值: %.1fcm)\n", 
                    obstacleDetected ? "是" : "否", obstacleThreshold);
      Serial.printf("⚠️ 警告状态: %s (阈值: %.1fcm)\n", 
                    obstacleWarning ? "是" : "否", warningThreshold);
      
      
      Serial.println("🚨 ========================\n");
    } else if (tof_sensor_available && !obstacle_avoidance_active) {
      Serial.println("🚫 ToF传感器可用但避障已禁用");
    } else if (!tof_sensor_available) {
      Serial.println("❌ ToF避障传感器不可用");
    }
    
    lastThermalTest = millis();
  }
  
  // 增加主循环延迟，减少CPU占用 (从100ms增加到200ms)
  delay(200);
}



//-------------------------------- FastLED Control Functions
void initLED() {
  Serial.println("🌈 开始初始化FastLED系统...");
  Serial.printf("📍 LED引脚: D2 (GPIO%d)\n", LED_PIN);
  Serial.printf("💡 LED数量: %d个WS2812B\n", NUM_LEDS);
  
  // 初始化FastLED
  FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
  FastLED.clear();
  FastLED.show();
  
  // LED连接测试 - 增强版本
  Serial.println("🧪 LED连接测试 (增强版)...");
  CRGB test_colors[] = {CRGB::Red, CRGB::Green, CRGB::Blue, CRGB::White, CRGB::Yellow, CRGB::Purple};
  String color_names[] = {"红色", "绿色", "蓝色", "白色", "黄色", "紫色"};
  
  for (int c = 0; c < 6; c++) {
    Serial.printf("🔴 测试 %s (全亮度)\n", color_names[c].c_str());
    fill_solid(leds, NUM_LEDS, test_colors[c]);
    FastLED.show();
    delay(500);
    
    // 测试亮度变化
    Serial.printf("🔅 测试 %s (亮度变化)\n", color_names[c].c_str());
    for (int brightness = 255; brightness >= 50; brightness -= 50) {
      fill_solid(leds, NUM_LEDS, test_colors[c]);
      FastLED.setBrightness(brightness);
      FastLED.show();
      Serial.printf("   亮度: %d\n", brightness);
      delay(200);
    }
    FastLED.setBrightness(255);  // 恢复全亮度
  }
  
  // 呼吸灯效果测试
  Serial.println("🫁 呼吸灯效果测试...");
  for (int cycle = 0; cycle < 3; cycle++) {
    for (int brightness = 50; brightness <= 255; brightness += 10) {
      fill_solid(leds, NUM_LEDS, CRGB::White);
      FastLED.setBrightness(brightness);
      FastLED.show();
      delay(50);
    }
    for (int brightness = 255; brightness >= 50; brightness -= 10) {
      fill_solid(leds, NUM_LEDS, CRGB::White);
      FastLED.setBrightness(brightness);
      FastLED.show();
      delay(50);
    }
  }
  
  // 清空并启动默认呼吸模式
  FastLED.setBrightness(255);  // 确保亮度设置正确
  // 不要清空LED，保持白色以便呼吸灯效果正常
  fill_solid(leds, NUM_LEDS, CRGB::White);  // 设置为白色
  FastLED.show();
  delay(200);
  
  Serial.println("✅ FastLED系统初始化完成");
  Serial.println("🫁 默认模式: 白色呼吸灯 (增强对比度)");
}

void updateLED() {
  static unsigned long last_debug = 0;
  bool debug_output = (millis() - last_debug > 10000);  // 减少到每10秒输出一次调试信息
  
  if (debug_output) {
    Serial.printf("🌈 LED更新: 启用=%s, 模式=%d\n", led_enabled ? "是" : "否", current_led_mode);
    last_debug = millis();
  }
  
  if (!led_enabled) {
    FastLED.clear();
    FastLED.show();
    return;
  }
  
  switch (current_led_mode) {
    case LED_BREATH:
      updateBreathEffect();
      if (debug_output) {
        Serial.printf("🫁 呼吸灯模式: 颜色=(%d,%d,%d), 全局亮度=%d\n", 
                      leds[0].r, leds[0].g, leds[0].b, FastLED.getBrightness());
      }
      break;
    case LED_RAINBOW:
      updateRainbowEffect();
      if (debug_output) {
        Serial.printf("🌈 彩虹模式: 色相=%d, LED0=(%d,%d,%d)\n", 
                      rainbow_hue, leds[0].r, leds[0].g, leds[0].b);
      }
      break;
    case LED_SOLID:
      updateSolidColor();
      if (debug_output) {
        Serial.printf("💡 固定颜色: (%d,%d,%d)\n", leds[0].r, leds[0].g, leds[0].b);
      }
      break;
    case LED_OFF:
      FastLED.clear();
      FastLED.setBrightness(0);  // 设置亮度为0
      if (debug_output) {
        Serial.println("⚫ LED关闭模式");
      }
      break;
  }
  
  // 只在非呼吸灯模式下调用FastLED.show()，因为updateBreathEffect()内部已经处理了
  if (current_led_mode != LED_BREATH) {
    FastLED.show();
  }
  
  if (debug_output) {
    Serial.printf("✅ FastLED处理完成 (模式=%d)\n", current_led_mode);
  }
}

void updateBreathEffect() {
  static unsigned long last_debug = 0;
  bool debug_output = (millis() - last_debug > 15000);  // 减少到每15秒输出一次调试信息
  
  // 根据WebSocket连接状态选择呼吸速度
  float current_speed = websocket_connected ? breath_speed_connected : breath_speed;
  
  // 更新呼吸相位 - 符合人体呼吸频率 (约12-20次/分钟)
  breath_phase += current_speed;
  if (breath_phase > TWO_PI) {
    breath_phase = 0.0;
  }
  
  // 使用更明显的亮度变化算法
  float sine_value = sin(breath_phase);
  // 将正弦值从[-1,1]映射到[0,1]，然后应用平方函数增强对比度
  float normalized = (sine_value + 1.0) / 2.0;
  float enhanced = normalized * normalized;  // 平方函数增强对比度
  
  // 简化颜色亮度检查 - 只在调试时计算
  int adjusted_min_brightness = min_brightness;
  int adjusted_max_brightness = max_brightness;
  
  // 如果是深色（如纯蓝色），增加亮度范围
  if (debug_output) {
    int color_brightness = (breath_color.r + breath_color.g + breath_color.b) / 3;
    if (color_brightness < 128) {
      adjusted_min_brightness = 80;   // 提高最小亮度
      adjusted_max_brightness = 255;  // 保持最大亮度
      Serial.printf("🔵 检测到深色，调整亮度范围: %d-%d\n", adjusted_min_brightness, adjusted_max_brightness);
    }
  }
  
  int current_brightness = adjusted_min_brightness + (int)((adjusted_max_brightness - adjusted_min_brightness) * enhanced);
  
  // 确保亮度在有效范围内
  current_brightness = constrain(current_brightness, adjusted_min_brightness, adjusted_max_brightness);
  
  if (debug_output) {
    Serial.printf("🫁 呼吸灯增强: 相位=%.2f, 正弦值=%.2f, 标准化=%.2f, 增强=%.2f, 亮度=%d\n", 
                  breath_phase, sine_value, normalized, enhanced, current_brightness);
    Serial.printf("🎨 基础颜色: R=%d, G=%d, B=%d (范围: %d-%d)\n", 
                  breath_color.r, breath_color.g, breath_color.b, adjusted_min_brightness, adjusted_max_brightness);
    last_debug = millis();
  }
  
  // 使用FastLED全局亮度控制，而不是直接修改RGB值
  // 先设置基础颜色到所有LED
  fill_solid(leds, NUM_LEDS, breath_color);
  
  // 然后使用FastLED的全局亮度控制
  FastLED.setBrightness(current_brightness);
  
  // 立即应用亮度设置
  FastLED.show();
  
  if (debug_output) {
    Serial.printf("🔍 设置全局亮度: %d, LED[0]基础颜色: R=%d, G=%d, B=%d\n", 
                  current_brightness, leds[0].r, leds[0].g, leds[0].b);
  }
}

void updateRainbowEffect() {
  rainbow_hue += 2;  // 彩虹色相递增
  
  // 确保全局亮度设置为最大
  FastLED.setBrightness(255);
  
  for (int i = 0; i < NUM_LEDS; i++) {
    // 每个LED有不同的色相偏移，创造彩虹效果
    leds[i] = CHSV(rainbow_hue + (i * 128), 255, 255);
  }
}

void updateSolidColor() {
  // 固定颜色模式
  fill_solid(leds, NUM_LEDS, breath_color);
  
  // 确保全局亮度设置为最大
  FastLED.setBrightness(255);
}

void setLEDMode(LedMode mode) {
  current_led_mode = mode;
  String mode_names[] = {"呼吸灯", "彩虹", "固定颜色", "关闭"};
  
  Serial.printf("🎨 LED模式切换: %s\n", mode_names[mode].c_str());
}

void setLEDColor(uint8_t r, uint8_t g, uint8_t b) {
  breath_color = CRGB(r, g, b);
  Serial.printf("🎨 LED颜色设置: R=%d, G=%d, B=%d\n", r, g, b);
}

void setLEDColor(CRGB color) {
  breath_color = color;
  Serial.printf("🎨 LED颜色设置: #%02X%02X%02X\n", color.r, color.g, color.b);
}

void setLEDEnabled(bool enabled) {
  led_enabled = enabled;
  if (!enabled) {
    FastLED.clear();
    FastLED.show();
  }
  Serial.printf("💡 LED %s\n", enabled ? "开启" : "关闭");
}

// 处理LED颜色命令 (格式: LED_COLOR:R,G,B)
void processLEDColorCommand(String command) {
  int colon_pos = command.indexOf(':');
  if (colon_pos == -1) {
    Serial.println("❌ LED颜色命令格式错误，应为 LED_COLOR:R,G,B");
    return;
  }
  
  String color_data = command.substring(colon_pos + 1);
  int comma1 = color_data.indexOf(',');
  int comma2 = color_data.lastIndexOf(',');
  
  if (comma1 == -1 || comma2 == -1 || comma1 == comma2) {
    Serial.println("❌ LED颜色数据格式错误，应为 R,G,B");
    return;
  }
  
  int r = color_data.substring(0, comma1).toInt();
  int g = color_data.substring(comma1 + 1, comma2).toInt();
  int b = color_data.substring(comma2 + 1).toInt();
  
  // 验证颜色值范围
  if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
    Serial.println("❌ LED颜色值超出范围 (0-255)");
    return;
  }
  
  setLEDColor(r, g, b);
  current_led_mode = LED_SOLID;  // 设置颜色后切换到固定颜色模式
  Serial.printf("✅ LED颜色已设置并切换到固定颜色模式\n");
}

//-------------------------------- HTTP Server Functions
static esp_err_t index_handler(httpd_req_t *req) {
  const char* html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skyris WebSocket Control</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f0f0f0; }
        .container { max-width: 1200px; margin: 0 auto; }
        .panel { background: white; border-radius: 10px; padding: 20px; margin: 10px 0; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-width: 300px; margin: 0 auto; }
        .btn { padding: 15px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; transition: all 0.3s; }
        .btn:hover { transform: scale(1.05); }
        .flight-btn { background: #4CAF50; color: white; }
        .flight-btn:hover { background: #45a049; }
        .led-btn { background: #2196F3; color: white; margin: 5px; }
        .led-btn:hover { background: #1976D2; }
        .status { padding: 10px; border-radius: 5px; margin: 10px 0; }
        .connected { background: #d4edda; color: #155724; }
        .disconnected { background: #f8d7da; color: #721c24; }
        .color-picker { margin: 10px; }
        
        /* Toggle Switch Styles */
        .switch-container { display: flex; align-items: center; gap: 10px; cursor: pointer; }
        .switch-container input[type="checkbox"] { opacity: 0; width: 0; height: 0; }
        .slider { position: relative; display: inline-block; width: 60px; height: 34px; background-color: #ccc; border-radius: 34px; transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; border-radius: 50%; transition: .4s; }
        .switch-container input:checked + .slider { background-color: #4CAF50; }
        .switch-container input:checked + .slider:before { transform: translateX(26px); }
        .switch-label { font-weight: bold; color: #333; }
        .preset-colors { display: flex; gap: 10px; margin: 10px 0; }
        .color-preset {
          width: 36px; height: 36px; border-radius: 50%; cursor: pointer; border: 2px solid #ccc;
          font-weight: bold; font-size: 14px; outline: none;
        }
        .color-preset:active { border: 2px solid #333; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🚁 Skyris WebSocket Control</h1>
        
        <div class="panel">
            <h2>🔌 Connection Status</h2>
            <div id="status" class="status disconnected">Disconnected</div>
        </div>
        
        <div class="panel">
            <h2>🎮 Flight Control & Data</h2>
            
            <!-- Flight Control Grid -->
            <div style="display: flex; gap: 20px; align-items: flex-start;">
                <!-- Control Buttons -->
                <div style="flex: 1;">
                    <h3 style="margin: 0 0 10px 0;">遥控器</h3>
                    <div class="grid">
                        <div></div>
                        <button class="btn flight-btn" onclick="sendCommand('UP')">⬆️ UP</button>
                        <div></div>
                        <button class="btn flight-btn" onclick="sendCommand('LEFT')">⬅️ LEFT</button>
                        <button class="btn flight-btn" onclick="sendCommand('IDLE')" style="background: #f44336;">🛑 STOP</button>
                        <button class="btn flight-btn" onclick="sendCommand('RIGHT')">➡️ RIGHT</button>
                        <button class="btn flight-btn" onclick="sendCommand('BACK')">⬇️ BACK</button>
                        <button class="btn flight-btn" onclick="sendCommand('DOWN')">⬇️ DOWN</button>
                        <button class="btn flight-btn" onclick="sendCommand('FWD')">⬆️ FWD</button>
                        <button class="btn flight-btn" onclick="sendCommand('LWAVE')" style="background: #9C27B0; font-size: 12px; padding: 8px 12px;">〰️ LEFT WAVE</button>
                        <button class="btn flight-btn" onclick="sendCommand('RWAVE')" style="background: #FF5722; font-size: 12px; padding: 8px 12px;">〰️ RIGHT WAVE</button>
                    </div>
                </div>
                
                <!-- Flight Modes -->
                <div style="flex: 1;">
                    <h3 style="margin: 0 0 10px 0;">飞行模式</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                        <button class="btn led-btn" onclick="sendCommand('MANUAL')" style="background: #FF9800; font-size: 12px;">🎮 Manual</button>
                        <!-- <button class="btn led-btn" onclick="sendCommand('TRACK')" style="background: #E91E63; font-size: 12px;">🔥 Track</button> 删除 -->
                        <button class="btn led-btn" onclick="sendCommand('CRUISE')" style="background: #9C27B0; font-size: 12px;">🎲 Cruise</button>
                        <button class="btn led-btn" onclick="sendCommand('ALTITUDE')" style="background: #4CAF50; font-size: 12px;">📏 Altitude</button>
                    </div>
                    <div id="currentMode" style="margin-top: 8px; font-weight: bold; font-size: 14px;">Current Mode: Manual</div>
                </div>
                
                <!-- Flight Data -->
                <div style="flex: 1;">
                    <h3 style="margin: 0 0 10px 0;">飞行数据</h3>
                    <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; font-size: 14px; margin-bottom: 10px;">
                        📏 <strong>高度:</strong> <span id="altitudeDisplay">-- m</span><br>
                        🎯 <strong>定高状态:</strong> <span id="altitudeStatus">--</span><br>
                        🛡️ <strong>避障状态:</strong> <span id="avoidanceStatus">--</span><br>
                        📡 <strong>ToF距离:</strong> <span id="distanceDisplay">-- cm</span>
                    </div>
                </div>
            </div>
            
            <!-- Quick Info Banner -->
            <div style="margin-top: 15px; padding: 8px; background: #e8f5e8; border-radius: 5px; font-size: 12px; text-align: center;">
                💡 <strong>提示:</strong> 定高模式自动保持1.5米悬停 | 避障模式50cm内自动停止 | 所有模式可组合使用
            </div>
        </div>
        
        <div class="panel">
            <h2>🌈 LED Control</h2>
            <div>
                <button class="btn led-btn" onclick="sendCommand('LED_BREATH')">🫁 Breathing</button>
                <button class="btn led-btn" onclick="sendCommand('LED_RAINBOW')">🌈 Rainbow</button>
                <button class="btn led-btn" onclick="sendCommand('LED_SOLID')">💡 Solid</button>
                <button class="btn led-btn" onclick="sendCommand('LED_OFF')">⚫ Off</button>
            </div>
            <div style="margin: 10px 0; padding: 10px; background: #e8f5e8; border-radius: 5px; font-size: 14px;">
                💡 <strong>提示:</strong> 呼吸灯模式使用当前选择的颜色，建议使用较亮的颜色以获得最佳效果
            </div>
            <div class="color-picker">
                <label>Custom Color: </label>
                <input type="color" id="colorPicker" value="#ffffff" onchange="updateColor()">
            </div>
            <div style="margin: 10px 0; font-weight: bold;">颜色选择：</div>
            <div class="preset-colors">
              <button class="color-preset" style="background: white; border: 1px solid #ccc;" onclick="setPresetColor(255,255,255)"></button>
              <button class="color-preset" style="background: red;" onclick="setPresetColor(255,0,0)"></button>
              <button class="color-preset" style="background: orange;" onclick="setPresetColor(255,128,0)"></button>
              <button class="color-preset" style="background: yellow; border: 1px solid #ccc;" onclick="setPresetColor(255,255,0)"></button>
              <button class="color-preset" style="background: green;" onclick="setPresetColor(0,255,0)"></button>
              <button class="color-preset" style="background: cyan;" onclick="setPresetColor(0,255,255)"></button>
              <button class="color-preset" style="background: blue;" onclick="setPresetColor(0,0,255)"></button>
              <button class="color-preset" style="background: purple;" onclick="setPresetColor(128,0,255)"></button>
            </div>
        </div>
        
        <div class="panel">
            <h2>📹 Camera Stream</h2>
            <img src="/stream" style="max-width: 100%; border-radius: 10px;">
        </div>
        
        <div class="panel">
            <h2>🚁 Obstacle Avoidance</h2>
            <div style="margin-bottom: 15px;">
                <label class="switch-container">
                    <input type="checkbox" id="obstacleToggle" onchange="toggleObstacleAvoidance()">
                    <span class="slider"></span>
                    <span class="switch-label">避障模式</span>
                </label>
            </div>
            <div id="obstacleStatus" style="margin: 10px 0; padding: 10px; background: #f5f5f5; border-radius: 5px; font-size: 14px;">
                🚫 避障已关闭
            </div>
            <div id="obstacleDetails" style="margin: 10px 0; padding: 10px; background: #e8f5e8; border-radius: 5px; font-size: 12px; display: none;">
                📊 <strong>传感器状态:</strong><br>
                • 距离: <span id="obstacleDistance">-- cm</span><br>
                • 阈值: 障碍物50cm / 警告60cm<br>
                • 传感器: <span id="sensorStatus">检测中...</span>
            </div>
            <div style="margin: 10px 0; padding: 10px; background: #fff3cd; border-radius: 5px; font-size: 12px;">
                ⚠️ <strong>注意:</strong> 避障模式会在检测到障碍物时自动覆盖飞行命令，优先级最高
            </div>
        </div>
    </div>

    <script>
        let ws;
        let wsConnected = false;
        
      function updateFlightData(data) {
    if (data.altitude !== undefined) {
        var altitudeSpan = document.getElementById('altitudeDisplay');
        if (altitudeSpan) {
            altitudeSpan.textContent = data.altitude.toFixed(2) + ' m';
            altitudeSpan.style.color = '#28a745';
        }
    }
      if (data.altitude_hold_enabled !== undefined) {
          var statusSpan = document.getElementById('altitudeStatus');
          if (statusSpan) {
              statusSpan.textContent = data.altitude_hold_enabled ? '✅ 定高已启用' : '⚫ 手动模式';
              statusSpan.style.color = '#28a745';
          }
      }
    if (data.avoidance_active !== undefined) {
        var avoidanceSpan = document.getElementById('avoidanceStatus');
        if (avoidanceSpan) {
            avoidanceSpan.textContent = data.avoidance_active ? '🛡️ 已启用' : '⚫ 已关闭';
            avoidanceSpan.style.color = '#28a745';
        }
    }
    if (data.tof_distance !== undefined) {
        var distanceSpan = document.getElementById('distanceDisplay');
        if (distanceSpan) {
            distanceSpan.textContent = data.tof_distance.toFixed(1) + ' cm';
            distanceSpan.style.color = '#28a745';
        }
    }
}
function updateCurrentMode(data) {
    // 主模式按钮
    const manualBtn = document.querySelector('button[onclick*="MANUAL"]');
    const cruiseBtn = document.querySelector('button[onclick*="CRUISE"]');
    // 副模式按钮
    const altitudeBtn = document.querySelector('button[onclick*="ALTITUDE"]');
    // 高亮主模式
    if (data.main_mode === 'MANUAL') {
        manualBtn && manualBtn.classList.add('active');
        cruiseBtn && cruiseBtn.classList.remove('active');
    } else if (data.main_mode === 'CRUISE') {
        cruiseBtn && cruiseBtn.classList.add('active');
        manualBtn && manualBtn.classList.remove('active');
    }
    // 高亮副模式
    if (altitudeBtn) {
        if (data.altitude_hold_enabled) altitudeBtn.classList.add('active');
        else altitudeBtn.classList.remove('active');
    }
    // 避障副模式（用checkbox或按钮，按你的UI结构处理）
    const obstacleToggle = document.getElementById('obstacleToggle');
    if (obstacleToggle) {
        obstacleToggle.checked = !!data.avoidance_active;
    }
    // 模式文本显示
    let modeText = (data.main_mode === 'CRUISE' ? '巡航' : '手动');
    let subModes = [];
    if (data.altitude_hold_enabled) subModes.push('定高');
    if (data.avoidance_active) subModes.push('避障');
    if (subModes.length > 0) modeText += ' + ' + subModes.join(' + ');
    const modeDiv = document.getElementById('currentMode');
    if (modeDiv) modeDiv.textContent = '当前模式: ' + modeText;

        // 避障详细状态
    if (data.avoidance_active !== undefined) {
        var details = document.getElementById('obstacleDetails');
        if (details) details.style.display = data.avoidance_active ? 'block' : 'none';
        var statusDiv = document.getElementById('obstacleStatus');
        if (statusDiv) {
            statusDiv.innerHTML = data.avoidance_active ? '🛡️ 避障模式已启用' : '🚫 避障已关闭';
            statusDiv.style.background = data.avoidance_active ? '#d4edda' : '#f5f5f5';
            statusDiv.style.color = data.avoidance_active ? '#155724' : '#666';
        }
    }
    if (data.tof_distance !== undefined) {
        var distSpan = document.getElementById('obstacleDistance');
        if (distSpan) distSpan.textContent = data.tof_distance.toFixed(1) + ' cm';
    }
    if (data.obstacle_detected !== undefined) {
        var sensorSpan = document.getElementById('sensorStatus');
        if (sensorSpan) sensorSpan.textContent = data.obstacle_detected ? '⚠️ 有障碍物' : '✅ 正常';
        if (sensorSpan) sensorSpan.style.color = data.obstacle_detected ? '#e53935' : '#28a745';
    }
}
        


        function connectWebSocket() {
            ws = new WebSocket('ws://' + window.location.hostname + ':81');
            ws.onopen = function() {
                wsConnected = true;
                document.getElementById('status').className = 'status connected';
                document.getElementById('status').textContent = 'Connected to WebSocket';
                console.log('WebSocket connected');
            };
            ws.onclose = function() {
                wsConnected = false;
                document.getElementById('status').className = 'status disconnected';
                document.getElementById('status').textContent = 'Disconnected - Reconnecting...';
                console.log('WebSocket disconnected');
                setTimeout(connectWebSocket, 3000);
            };
            ws.onmessage = function(event) {
    try {
        const data = JSON.parse(event.data);
        if (data.type === 'status') {
            updateFlightData(data);
            updateCurrentMode(data);
        } else if (data.type === 'mode') {
            updateCurrentMode(data);
        } else if (data.type === 'response') {
            // ...原有处理...
        }
    } catch (e) {
        console.log('Non-JSON message:', event.data);
    }
};
            ws.onerror = function(error) {
                console.log('WebSocket error:', error);
            };
        }
        
        function sendCommand(command) {
            if (wsConnected && ws.readyState === WebSocket.OPEN) {
                ws.send(command);
                console.log('Sent command:', command);
            } else {
                console.log('WebSocket not connected');
            }
        }
        
        
        function updateColor() {
            const color = document.getElementById('colorPicker').value;
            const r = parseInt(color.substr(1, 2), 16);
            const g = parseInt(color.substr(3, 2), 16);
            const b = parseInt(color.substr(5, 2), 16);
            sendCommand(`LED_COLOR:${r},${g},${b}`);
        }
        
        function setPresetColor(r, g, b) {
            sendCommand(`LED_COLOR:${r},${g},${b}`);
            const hex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            document.getElementById('colorPicker').value = hex;
        }
        
        // Connect on page load
        connectWebSocket();
        
        function toggleObstacleAvoidance() {
            const toggle = document.getElementById('obstacleToggle');
            const status = document.getElementById('obstacleStatus');
            const details = document.getElementById('obstacleDetails');
            
            if (toggle.checked) {
                sendCommand('TOF_ENABLE');
                status.innerHTML = '🛡️ 避障模式已启用';
                status.style.background = '#d4edda';
                status.style.color = '#155724';
                details.style.display = 'block';
                console.log('启用避障模式');
            } else {
                sendCommand('TOF_DISABLE');
                status.innerHTML = '🚫 避障已关闭';
                status.style.background = '#f5f5f5';
                status.style.color = '#666';
                details.style.display = 'none';
                console.log('关闭避障模式');
            }
        }
    </script>
</body>
</html>
)rawliteral";
  
  httpd_resp_set_type(req, "text/html");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  return httpd_resp_send(req, html, strlen(html));
}



static esp_err_t mode_handler(httpd_req_t *req) {
  size_t buf_len = httpd_req_get_url_query_len(req) + 1;
  if (buf_len > 1) {
    char* buf = (char*)malloc(buf_len);
    if (httpd_req_get_url_query_str(req, buf, buf_len) == ESP_OK) {
      char param[32];
      if (httpd_query_key_value(buf, "mode", param, sizeof(param)) == ESP_OK) {
        String mode = String(param);
        mode.toUpperCase();
        processCommand(mode);
      }
    }
    free(buf);
  }
  
  httpd_resp_set_type(req, "text/plain");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  return httpd_resp_send(req, "OK", 2);
}

static esp_err_t capture_handler(httpd_req_t *req) {
  camera_fb_t *fb = esp_camera_fb_get();
  if (!fb) {
    httpd_resp_send_500(req);
    return ESP_FAIL;
  }
  
  httpd_resp_set_type(req, "image/jpeg");
  httpd_resp_set_hdr(req, "Content-Disposition", "inline; filename=capture.jpg");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  
  esp_err_t res = httpd_resp_send(req, (const char *)fb->buf, fb->len);
  esp_camera_fb_return(fb);
  
  return res;
}

#define PART_BOUNDARY "123456789000000000000987654321"
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" PART_BOUNDARY;
static const char* _STREAM_BOUNDARY = "\r\n--" PART_BOUNDARY "\r\n";
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

static esp_err_t stream_handler(httpd_req_t *req) {
  Serial.println("📹 收到视频流请求");
  
  camera_fb_t *fb = NULL;
  esp_err_t res = ESP_OK;
  char part_buf[128];
  
  res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if (res != ESP_OK) {
    Serial.printf("❌ 设置响应类型失败: %d\n", res);
    return res;
  }
  
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  httpd_resp_set_hdr(req, "Cache-Control", "no-cache, no-store, must-revalidate");
  httpd_resp_set_hdr(req, "Pragma", "no-cache");
  httpd_resp_set_hdr(req, "Expires", "0");
  Serial.println("✅ 视频流响应头设置完成");
  
  int frame_count = 0;
  unsigned long last_frame_time = millis();
  
  while (true) {
    unsigned long frame_start = millis();
    
    fb = esp_camera_fb_get();
    if (!fb) {
      Serial.printf("❌ 获取摄像头帧失败 (帧#%d)\n", frame_count);
      res = ESP_FAIL;
      break;
    }
    
    // 减少调试输出频率，避免影响性能
    if (frame_count % 100 == 0) {  // 每100帧输出一次调试信息
      unsigned long fps = 1000 / (millis() - last_frame_time + 1);
      Serial.printf("📹 视频流正常 - 帧#%d, 大小=%d bytes, FPS≈%lu\n", frame_count, fb->len, fps);
      last_frame_time = millis();
    }
    
    // 发送边界
    if (res == ESP_OK) {
      res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    }
    
    // 发送头部
    if (res == ESP_OK) {
      size_t hlen = snprintf(part_buf, 128, _STREAM_PART, fb->len);
      res = httpd_resp_send_chunk(req, part_buf, hlen);
    }
    
    // 发送图像数据
    if (res == ESP_OK) {
      res = httpd_resp_send_chunk(req, (const char *)fb->buf, fb->len);
    }
    
    esp_camera_fb_return(fb);
    
    if (res != ESP_OK) {
      Serial.printf("❌ 视频流发送失败: %d (帧#%d)\n", res, frame_count);
      break;
    }
    
    frame_count++;
    
    // 动态帧率控制 - 根据处理时间调整延迟
    unsigned long frame_time = millis() - frame_start;
    if (frame_time < 66) {  // 目标15FPS (66ms per frame)
      vTaskDelay(pdMS_TO_TICKS(66 - frame_time));
    } else {
      vTaskDelay(pdMS_TO_TICKS(10));  // 最小延迟，避免阻塞其他任务
    }
  }
  
  Serial.printf("📹 视频流结束 - 总帧数: %d\n", frame_count);
  return res;
}

void startCameraServer() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 80;
  config.max_uri_handlers = 10;
  config.task_priority = 5;  // 提高HTTP优先级 (从4提高到5)
  config.stack_size = 12288;  // 增加栈大小 (从8192增加到12288)
  config.core_id = 0;
  config.max_open_sockets = 5;  // 减少最大连接数，提高稳定性
  config.lru_purge_enable = true;  // 启用LRU清理
  config.recv_wait_timeout = 10;   // 减少接收超时
  config.send_wait_timeout = 10;   // 减少发送超时
  
  Serial.println("🔧 开始启动HTTP服务器...");
  
  if (httpd_start(&camera_httpd, &config) == ESP_OK) {
    Serial.println("✅ HTTP服务器启动成功，开始注册路由...");
    
    httpd_uri_t index_uri = {.uri = "/", .method = HTTP_GET, .handler = index_handler, .user_ctx = NULL};
    if (httpd_register_uri_handler(camera_httpd, &index_uri) == ESP_OK) {
      Serial.println("✅ 注册路由: /");
    } else {
      Serial.println("❌ 注册路由失败: /");
    }
    
    httpd_uri_t capture_uri = {.uri = "/capture", .method = HTTP_GET, .handler = capture_handler, .user_ctx = NULL};
    if (httpd_register_uri_handler(camera_httpd, &capture_uri) == ESP_OK) {
      Serial.println("✅ 注册路由: /capture");
    } else {
      Serial.println("❌ 注册路由失败: /capture");
    }
    
    httpd_uri_t stream_uri = {.uri = "/stream", .method = HTTP_GET, .handler = stream_handler, .user_ctx = NULL};
    if (httpd_register_uri_handler(camera_httpd, &stream_uri) == ESP_OK) {
      Serial.println("✅ 注册路由: /stream");
    } else {
      Serial.println("❌ 注册路由失败: /stream");
    }
    
    httpd_uri_t mode_uri = {.uri = "/mode", .method = HTTP_GET, .handler = mode_handler, .user_ctx = NULL};
    if (httpd_register_uri_handler(camera_httpd, &mode_uri) == ESP_OK) {
      Serial.println("✅ 注册路由: /mode");
    } else {
      Serial.println("❌ 注册路由失败: /mode");
    }
    
    
    Serial.println("✅ HTTP服务器和所有路由注册完成");
    Serial.printf("📊 HTTP服务器优化配置: 端口=%d, 优先级=%d, 栈大小=%d, 连接数=%d\n", 
                  config.server_port, config.task_priority, config.stack_size, config.max_open_sockets);
  } else {
    Serial.println("❌ HTTP服务器启动失败");
  }
}

//==================== 新增多任务任务函数定义 ====================
void ToFTask(void* parameter) {
  for(;;) {
    // ==== ToF避障传感器采集与处理逻辑迁移 ====
    if (!tof_sensor_available) {
      vTaskDelay(20 / portTICK_PERIOD_MS);
      continue;
    }
    static int errorCount = 0;
    static unsigned long lastValidTime = 0;
    static float lastValidDistance = 0.0;
    // 读取传感器数据
    tof_distance_mm = tof_sensor.read();
    tof_range_status = tof_sensor.ranging_data.range_status;
    // 转换为厘米
    float newDistance = tof_distance_mm / 10.0;
    // 数据有效性检查 - 放宽条件，接受状态0、1、2
    if ((tof_range_status == 0 || tof_range_status == 1 || tof_range_status == 2) && 
        newDistance >= 3.0 && newDistance <= 400.0) {
      tof_distance_cm = newDistance;
      currentAltitude = tof_distance_cm / 100.0; // cm转米，保证定高逻辑用到的高度数据是最新的
      lastValidDistance = newDistance;
      lastValidTime = millis();
      errorCount = 0;
      // 更新障碍物状态
      if (newDistance <= obstacleThreshold) {
        obstacleDetected = true;
        obstacleWarning = false;
      } else if (newDistance <= warningThreshold) {
        obstacleDetected = false;
        obstacleWarning = true;
      } else {
        obstacleDetected = false;
        obstacleWarning = false;
      }
    } else {
      errorCount++;
      // 如果连续错误超过5次，重置传感器
      if (errorCount > 5) {
        Serial.printf("⚠️ VL53L1X连续错误过多 (%d次), 状态=%d, 距离=%d mm\n", 
                      errorCount, tof_range_status, tof_distance_mm);
        tof_sensor.startContinuous(100);  // 使用更长间隔
        errorCount = 0;
      }
      // 使用上次有效数据 (如果在5秒内)
      if (millis() - lastValidTime < 5000) {
        tof_distance_cm = lastValidDistance;
      } else {
        // 超过5秒没有有效数据，设为安全距离
        tof_distance_cm = 100.0;
        obstacleDetected = false;
        obstacleWarning = false;
      }
    }
    // 调试输出 (每10秒一次)
    static unsigned long lastDebug = 0;
    if (millis() - lastDebug > 10000) {
      if (obstacle_avoidance_active) {
        Serial.printf("📏 ToF避障: 距离=%.1fcm, 状态=%d, 障碍=%s, 警告=%s, 错误=%d\n", 
                      tof_distance_cm, tof_range_status, 
                      obstacleDetected ? "是" : "否", 
                      obstacleWarning ? "是" : "否", 
                      errorCount);
      }
      lastDebug = millis();
    }
    vTaskDelay(20 / portTICK_PERIOD_MS); // 50Hz
  }
}


void ServoTask(void* parameter) {
  for(;;) {
    // ==== 舵机分步动作状态机逻辑 ====
    if (stop_motion) {
      Serial.printf("[ServoTask] stop_motion触发，当前指令: %s，回中位\n", cmdMap[current_direction]);
      stop_motion = false;
      motion_in_progress = false;
      current_direction = IDLE;
      servoState.direction = IDLE;
      servoState.in_progress = false;
      setServoIdle();
      vTaskDelay(10 / portTICK_PERIOD_MS);
      continue;
    }
    // 检查是否有新动作
    if (direction_changed) {
      Serial.printf("[ServoTask] direction_changed触发: %s -> %s\n", cmdMap[current_direction], cmdMap[target_direction]);
      // ====== 非阻塞UP补偿逻辑 ======
      if ((target_direction == FORWARD || target_direction == LEFT || target_direction == RIGHT)
          && altitudeHoldEnabled) {
        float delta = targetAltitude - currentAltitude;
        int maxN = 5, minN = 0;
        float maxDelta = 0.5; // 最大补偿区间（如0.5m）
        int upCount = minN;
        if (delta > 0) {
          upCount = minN + (int)((maxN - minN) * (delta / maxDelta));
          if (upCount > maxN) upCount = maxN;
          if (upCount < minN) upCount = minN;
        }
        pendingUpCompensate = upCount;
        Serial.printf("[ServoTask] 平面动作切换，UP补偿次数: %d (高度差: %.2f, 目标: %.2f, 当前: %.2f)\n", upCount, delta, targetAltitude, currentAltitude);
      }
      // ====== 非阻塞UP补偿逻辑结束 ======
      direction_changed = false;
      current_direction = target_direction;
      servoState.direction = target_direction;
      servoState.Ind_var = 0;
      servoState.in_progress = (servoState.direction != IDLE);
      servoState.continuous = continuous_motion;
      servoState.last_step_time = millis();
      Serial.printf("[ServoTask] 新动作: %s, continuous_motion=%d\n", cmdMap[servoState.direction], continuous_motion);

      // 新增：每次推进都打印当前指令
      Serial.printf("正在执行: %s\n", cmdMap[servoState.direction]);

      // 新增：切换指令时，先平滑过渡到新动作起始角度
      // 计算新动作的初始角度
      float angleL = mid_angle, angleR = mid_angle, angleLB = mid_angle, angleRB = mid_angle;
      switch (servoState.direction) {
        case FORWARD:
          angleL = 45 * sin(0 * PI / 180 - PI/2) + 135;
          angleR = 45 * sin(0 * PI / 180 + PI/2) + 45;
          angleLB = mid_angle;
          angleRB = mid_angle;
          break;
        case LEFT:
          angleL = mid_angle;
          angleR = 45 * sin(0 * PI / 180 + PI/2) + 45;
          angleLB = mid_angle;
          angleRB = mid_angle;
          break;
        case RIGHT:
          angleL = 45 * sin(0 * PI / 180 - PI/2) + 135;
          angleR = mid_angle;
          angleLB = mid_angle;
          angleRB = mid_angle;
          break;
        case UP:
          angleL = 45 * sin(0 * PI / 180 - PI/2) + 135;
          angleR = 45 * sin(0 * PI / 180 + PI/2) + 45;
          angleLB = min_angle;
          angleRB = max_angle;
          break;
        case DOWN:
          angleL = 45 * sin(0 * PI / 180 - PI/2) + 135;
          angleR = 45 * sin(0 * PI / 180 + PI/2) + 45;
          angleLB = max_angle;
          angleRB = min_angle;
          break;
        default:
          angleL = mid_angle;
          angleR = mid_angle;
          angleLB = mid_angle;
          angleRB = mid_angle;
          break;
      }
      // 平滑过渡到新动作起始角度
      bool all_ready = false;
      while (!all_ready) {
        all_ready = true;
        sla_current = smoothMove(sla_current, angleL, servo_step);
        sra_current = smoothMove(sra_current, angleR, servo_step);
        slb_current = smoothMove(slb_current, angleLB, servo_step);
        srb_current = smoothMove(srb_current, angleRB, servo_step);
        sla.write(sla_current);
        sra.write(sra_current);
        slb.write(slb_current);
        srb.write(srb_current);
        if (sla_current != angleL || sra_current != angleR || slb_current != angleLB || srb_current != angleRB) {
          all_ready = false;
        }
        vTaskDelay(10 / portTICK_PERIOD_MS);
      }
      if (servoState.direction == IDLE) {
        setServoIdle();
        motion_in_progress = false;
      } else {
        motion_in_progress = true;
        Serial.printf("⚡ 开始执行: %s\n", cmdMap[servoState.direction]);
      }
    }
    // 没有动作在进行
    if (!servoState.in_progress || servoState.direction == IDLE) {
      vTaskDelay(10 / portTICK_PERIOD_MS);
      continue;
    }
    // 分步推进动作
    if (millis() - servoState.last_step_time >= 10) { // 步进频率改为20ms，减少电源负载
      float Ind_var = servoState.Ind_var;
      float interval_tims = servoState.interval_tims;
      int dir = servoState.direction;

      switch (dir) {
        case FORWARD:
        case LEFT:
        case RIGHT:
          servoState.interval_tims = 6.0;
          break;
        case DOWN:
          servoState.interval_tims = 6.0;
          break;
        case UP:
          servoState.interval_tims = 6.0;
          break;
        default:
          servoState.interval_tims = 6.0;
          break;
      }
      interval_tims = servoState.interval_tims;

      switch (dir) {
        case FORWARD: {
          float angleL = 45 * sin(Ind_var * PI / 180 - PI/2) + 135;
          float angleR = 45 * sin(Ind_var * PI / 180 + PI/2) + 45;
          float angleLB = mid_angle;
          float angleRB = mid_angle;
          if (isnan(angleL) || isinf(angleL)) angleL = mid_angle;
          if (isnan(angleR) || isinf(angleR)) angleR = mid_angle;
          // 平滑插值
          sla_current = smoothMove(sla_current, angleL, servo_step);
          sra_current = smoothMove(sra_current, angleR, servo_step);
          slb_current = smoothMove(slb_current, angleLB, servo_step);
          srb_current = smoothMove(srb_current, angleRB, servo_step);
          sla.write(sla_current);
          sra.write(sra_current);
          slb.write(slb_current);
          srb.write(srb_current);
          servoState.Ind_var += interval_tims;
          if (servoState.Ind_var > 360) {
            if (servoState.continuous) {
              servoState.Ind_var = 0;
            } else {
              servoState.in_progress = false;
              motion_in_progress = false;
              continuous_motion = false;
              // 不要重置角度，不要直接写中位
              setServoIdle();
              Serial.printf("✅ FORWARD动作完成\n");
            }
          }
          break;
        }
        case LEFT: {
          float angleL = mid_angle;
          float angleR = 45 * sin(Ind_var * PI / 180 + PI/2) + 45;
          float angleLB = mid_angle;
          float angleRB = mid_angle;
          if (isnan(angleR) || isinf(angleR)) angleR = mid_angle;
          sla_current = smoothMove(sla_current, angleL, servo_step);
          sra_current = smoothMove(sra_current, angleR, servo_step);
          slb_current = smoothMove(slb_current, angleLB, servo_step);
          srb_current = smoothMove(srb_current, angleRB, servo_step);
          sla.write(sla_current);
          sra.write(sra_current);
          slb.write(slb_current);
          srb.write(srb_current);
          servoState.Ind_var += interval_tims;
          if (servoState.Ind_var > 360) {
            if (servoState.continuous) {
              servoState.Ind_var = 0;
            } else {
              servoState.in_progress = false;
              motion_in_progress = false;
              continuous_motion = false;
              setServoIdle();
              Serial.printf("✅ LEFT动作完成\n");
            }
          }
          break;
        }
        case RIGHT: {
          float angleL = 45 * sin(Ind_var * PI / 180 - PI/2) + 135;
          float angleR = mid_angle;
          float angleLB = mid_angle;
          float angleRB = mid_angle;
          if (isnan(angleL) || isinf(angleL)) angleL = mid_angle;
          sla_current = smoothMove(sla_current, angleL, servo_step);
          sra_current = smoothMove(sra_current, angleR, servo_step);
          slb_current = smoothMove(slb_current, angleLB, servo_step);
          srb_current = smoothMove(srb_current, angleRB, servo_step);
          sla.write(sla_current);
          sra.write(sra_current);
          slb.write(slb_current);
          srb.write(srb_current);
          servoState.Ind_var += interval_tims;
          if (servoState.Ind_var > 360) {
            if (servoState.continuous) {
              servoState.Ind_var = 0;
            } else {
              servoState.in_progress = false;
              motion_in_progress = false;
              continuous_motion = false;
              setServoIdle();
              Serial.printf("✅ RIGHT动作完成\n");
            }
          }
          break;
        }
        case UP: {
          float angleL = 45 * sin(Ind_var * PI / 180 - PI/2) + 135;
          float angleR = 45 * sin(Ind_var * PI / 180 + PI/2) + 45;
          float angleLB = min_angle;
          float angleRB = max_angle;
          if (isnan(angleL) || isinf(angleL)) angleL = mid_angle;
          if (isnan(angleR) || isinf(angleR)) angleR = mid_angle;
          sla_current = smoothMove(sla_current, angleL, servo_step);
          sra_current = smoothMove(sra_current, angleR, servo_step);
          slb_current = smoothMove(slb_current, angleLB, servo_step);
          srb_current = smoothMove(srb_current, angleRB, servo_step);
          sla.write(sla_current);
          sra.write(sra_current);
          slb.write(slb_current);
          srb.write(srb_current);
          // 已彻底移除动态速度调整代码
          servoState.Ind_var += interval_tims;
          if (servoState.Ind_var > 360) {
            if (servoState.continuous) {
              servoState.Ind_var = 0;
            } else {
              servoState.in_progress = false;
              motion_in_progress = false;
              continuous_motion = false;
              setServoIdle();
              Serial.printf("✅ UP动作完成\n");
            }
          }
          break;
        }
        case DOWN: {
          float angleL = 45 * sin(Ind_var * PI / 180 - PI/2) + 135;
          float angleR = 45 * sin(Ind_var * PI / 180 + PI/2) + 45;
          float angleLB = max_angle;
          float angleRB = min_angle;
          if (isnan(angleL) || isinf(angleL)) angleL = mid_angle;
          if (isnan(angleR) || isinf(angleR)) angleR = mid_angle;
          sla_current = smoothMove(sla_current, angleL, servo_step);
          sra_current = smoothMove(sra_current, angleR, servo_step);
          slb_current = smoothMove(slb_current, angleLB, servo_step);
          srb_current = smoothMove(srb_current, angleRB, servo_step);
          sla.write(sla_current);
          sra.write(sra_current);
          slb.write(slb_current);
          srb.write(srb_current);
          // 已彻底移除动态速度调整代码
          servoState.Ind_var += interval_tims;
          if (servoState.Ind_var > 360) {
            if (servoState.continuous) {
              servoState.Ind_var = 0;
            } else {
              servoState.in_progress = false;
              motion_in_progress = false;
              continuous_motion = false;
              setServoIdle();
              Serial.printf("✅ DOWN动作完成\n");
            }
          }
          break;
        }
        // 其它动作可按需补充
      }
      servoState.last_step_time = millis();
    }
    // 主循环优先处理UP补偿
    if (pendingUpCompensate > 0) {
      if (!servoState.in_progress) {
        servoState.direction = UP;
        servoState.Ind_var = 0;
        servoState.in_progress = true;
        servoState.continuous = false;
        pendingUpCompensate--;
        Serial.printf("[ServoTask] 执行UP补偿，剩余: %d\n", pendingUpCompensate);
      }
      // 补偿未完成前不切换到目标动作
      vTaskDelay(2 / portTICK_PERIOD_MS);
      continue;
    }
    vTaskDelay(2 / portTICK_PERIOD_MS); // 高速响应
  }
}
void LEDTask(void* parameter) {
  for(;;) {
    // ==== LED效果更新逻辑迁移 ====
    static unsigned long last_debug = 0;
    bool debug_output = (millis() - last_debug > 10000);
    if (debug_output) {
      Serial.printf("🌈 LED更新: 启用=%s, 模式=%d\n", led_enabled ? "是" : "否", current_led_mode);
      last_debug = millis();
    }
    if (!led_enabled) {
      FastLED.clear();
      FastLED.show();
      vTaskDelay(50 / portTICK_PERIOD_MS);
      continue;
    }
    switch (current_led_mode) {
      case LED_BREATH:
        updateBreathEffect();
        if (debug_output) {
          Serial.printf("🫁 呼吸灯模式: 颜色=(%d,%d,%d), 全局亮度=%d\n", 
                        leds[0].r, leds[0].g, leds[0].b, FastLED.getBrightness());
        }
        break;
      case LED_RAINBOW:
        updateRainbowEffect();
        if (debug_output) {
          Serial.printf("🌈 彩虹模式: 色相=%d, LED0=(%d,%d,%d)\n", 
                        rainbow_hue, leds[0].r, leds[0].g, leds[0].b);
        }
        FastLED.show();
        break;
      case LED_SOLID:
        updateSolidColor();
        if (debug_output) {
          Serial.printf("💡 固定颜色: (%d,%d,%d)\n", leds[0].r, leds[0].g, leds[0].b);
        }
        FastLED.show();
        break;
      case LED_OFF:
        FastLED.clear();
        FastLED.setBrightness(0);
        if (debug_output) {
          Serial.println("⚫ LED关闭模式");
        }
        FastLED.show();
        break;
    }
    if (debug_output) {
      Serial.printf("✅ FastLED处理完成 (模式=%d)\n", current_led_mode);
    }
    vTaskDelay(50 / portTICK_PERIOD_MS); // 20Hz
  }
}
void FlightControlTask(void* parameter) {
  for(;;) {
    unsigned long current_time = millis();
    // 只保留定高控制和巡航逻辑
    if (altitudeHoldEnabled && tof_sensor_available) {
      static unsigned long lastAltitudeControl = 0;
      if (current_time - lastAltitudeControl >= altitudeControlInterval) {
        int altitude_command = calculateAltitudeControl();
        Serial.printf("[FlightControlTask] 高度: %.2f, 当前指令: %s, 计算结果: %s\n", currentAltitude, cmdMap[current_direction], cmdMap[altitude_command]);
        if (altitude_command != IDLE && altitude_command != current_direction) {
          target_direction = altitude_command;
          direction_changed = true;
          continuous_motion = true;
          Serial.printf("[FlightControlTask] 切换目标指令: %s -> %s\n", cmdMap[current_direction], cmdMap[altitude_command]);
        } else if (current_direction == UP && altitude_command == IDLE) {
          target_direction = IDLE;
          direction_changed = true;
          continuous_motion = false;
          stop_motion = true;
          Serial.println("[FlightControlTask] 🛑 高度达标，停止UP动作 (stop_motion = true)");
        }
        lastAltitudeControl = current_time;
      }
    }
    if (flight_mode == CRUISE_MODE) {
      static unsigned long last_cruise_time = 0;
      if (current_time - last_cruise_time >= cruise_interval) {
        int random_directions[] = {FORWARD, LEFT, RIGHT};
        int random_dir = random(3);
        int cruise_command = random_directions[random_dir];
        if ((!altitudeHoldEnabled || calculateAltitudeControl() == IDLE)) {
          target_direction = cruise_command;
          direction_changed = true;
          continuous_motion = true;
          Serial.printf("[FlightControlTask] 🎲 随机巡航: 方向=%s\n", cmdMap[cruise_command]);
        }
        last_cruise_time = current_time;
      }
    }
    vTaskDelay(20 / portTICK_PERIOD_MS); // 50Hz
  }
}
//==================== End ====================


// ========== 新增：根据高度误差动态调整舵机速度 ===========
float getUpIntervalTims() {
  float min_tims = 1.0; // 最慢（靠近1.5m）
  float max_tims = 8.0; // 最快（远离1.5m）
  float low = 0.5, high = 0.7;
  if (currentAltitude < low) return max_tims;
  if (currentAltitude >= high) return min_tims;
  float ratio = (high - currentAltitude) / (high - low); // 1~0
  return min_tims + (max_tims - min_tims) * ratio;
}

float getDownIntervalTims() {
  float min_tims = 1.0; // 最慢（靠近1.8m）
  float max_tims = 8.0; // 最快（远离1.8m）
  float low = 1.8, high = 2.0;
  if (currentAltitude > high) return max_tims;
  if (currentAltitude <= low) return min_tims;
  float ratio = (currentAltitude - low) / (high - low); // 0~1
  return min_tims + (max_tims - min_tims) * (1 - ratio);
}
