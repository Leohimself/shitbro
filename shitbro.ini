// Skyris Dualâ€‘Stream (ESP32â€‘S3 XIAO Sense) â€” ESP32 Native HTTP Server with Thermal Imaging
// 2025â€‘05â€‘26 ULTRA FAST VERSION - WiFi Station Mode (è¿æ¥ç°æœ‰WiFiç½‘ç»œ)
//
// ğŸ”§ WiFié…ç½®è¯´æ˜:
// 1. ä¿®æ”¹ä¸‹é¢çš„WIFI_SSIDä¸ºä½ çš„WiFiç½‘ç»œåç§°
// 2. ä¿®æ”¹ä¸‹é¢çš„WIFI_PASSä¸ºä½ çš„WiFiå¯†ç 
// 3. ç¡®ä¿ç›®æ ‡WiFiç½‘ç»œåœ¨èŒƒå›´å†…ä¸”å¯è¿æ¥
// 4. ç¼–è¯‘å¹¶ä¸Šä¼ ä»£ç åˆ°ESP32
// 5. é€šè¿‡Serial MonitoræŸ¥çœ‹è¿æ¥çŠ¶æ€å’ŒIPåœ°å€
// 6. ä½¿ç”¨è·å¾—çš„IPåœ°å€è®¿é—®Webç•Œé¢
//
// ğŸ“± è®¿é—®æ–¹å¼:
// - Webç•Œé¢: http://[è®¾å¤‡IPåœ°å€]
// - WebSocket: ws://[è®¾å¤‡IPåœ°å€]:81
// - è®¾å¤‡IPåœ°å€ä¼šåœ¨Serial Monitorä¸­æ˜¾ç¤º
//
// âš ï¸ æ³¨æ„äº‹é¡¹:
// - å¦‚æœWiFiè¿æ¥å¤±è´¥ï¼Œè®¾å¤‡å°†ä»¥ç¦»çº¿æ¨¡å¼è¿è¡Œ
// - ä¼ æ„Ÿå™¨å’ŒèˆµæœºåŠŸèƒ½ä¸å—WiFiå½±å“
// - å¯é€šè¿‡Serial Monitorç›‘æ§æ‰€æœ‰åŠŸèƒ½çŠ¶æ€

#include <Arduino.h>
#include <WiFi.h>

// è§£å†³sensor_tç±»å‹å†²çªçš„ç»ˆææ–¹æ¡ˆï¼šé‡å‘½åESP32æ‘„åƒå¤´çš„sensor_t
#define sensor_t camera_sensor_t
#include <esp_camera.h>
#include <esp_http_server.h>
#include <esp_timer.h>
#undef sensor_t

// ç„¶åå®‰å…¨åŒ…å«å…¶ä»–åº“å’ŒAdafruitä¼ æ„Ÿå™¨åº“
#include <ESP32Servo.h>
#include <Wire.h>
#include <WebSocketsServer.h>


//-------------------------------- FastLED Configuration
// #define LED_PIN     2    // æ”¹ä¸ºXIAO ESP32S3çš„D2å¼•è„š (GPIO2)
// #define NUM_LEDS    2    // ä½¿ç”¨2ä¸ªLEDç¯ç 
// #define LED_TYPE    WS2812B
// #define COLOR_ORDER GRB

// LED control variable
// enum LedMode {
//   LED_BREATH,      // å‘¼å¸ç¯æ¨¡å¼
//   LED_RAINBOW,     // å½©è™¹æ¨¡å¼
//   LED_SOLID,       // å›ºå®šé¢œè‰²æ¨¡å¼
//   LED_OFF          // å…³é—­æ¨¡å¼
// };

// volatile LedMode current_led_mode = LED_BREATH;
// CRGB breath_color = CRGB::White;  // æ”¹ä¸ºç™½è‰²ï¼Œæ›´å®¹æ˜“çœ‹åˆ°äº®åº¦å˜åŒ–
// volatile bool led_enabled = true;

// WebSocket connection status
// volatile bool websocket_connected = false;
// WebSocketsServer webSocket = WebSocketsServer(81);  // WebSocket port 81

// å‘¼å¸ç¯å‚æ•° - ç¬¦åˆäººä½“å‘¼å¸é¢‘ç‡ï¼Œå¢åŠ äº®åº¦èŒƒå›´
// float breath_phase = 0.0;
// float breath_speed = 0.2;  // å¿«é€Ÿå‘¼å¸ (çº¦3ç§’ä¸€ä¸ªå‘¨æœŸï¼Œç±»ä¼¼æµ‹è¯•æ—¶é€Ÿåº¦)
// float breath_speed_connected = 0.15;  // WebSocket connectionåç¨æ…¢ (çº¦4ç§’ä¸€ä¸ªå‘¨æœŸ)
// int max_brightness = 255;  // æœ€å¤§äº®åº¦
// int min_brightness = 50;   // æé«˜æœ€å°äº®åº¦ï¼Œè®©å˜åŒ–æ›´æ˜æ˜¾

// å½©è™¹æ•ˆæœå‚æ•°
// uint8_t rainbow_hue = 0;

// LED command extensions
// const char* led_commands[] = {"LED_BREATH", "LED_RAINBOW", "LED_SOLID", "LED_OFF", "LED_COLOR"};

//-------------------------------- Wiâ€‘Fi Station Mode Configuration
#define WIFI_SSID "hupan"        // ä¿®æ”¹ä¸ºä½ çš„WiFiç½‘ç»œåç§°
#define WIFI_PASS "hupan@HYR2014525"    // ä¿®æ”¹ä¸ºä½ çš„WiFiå¯†ç 
#define WIFI_TIMEOUT 30000                // WiFi connection timeout (30 seconds)

String device_ip = "";  // å­˜å‚¨è®¾å¤‡IPåœ°å€

//-------------------------------- Direction Definitions (moved here to fix compilation order)
#define IDLE     0
#define FORWARD  1
#define UP       2
#define DOWN     3
#define LEFT     4
#define RIGHT    5
#define BACKWARD 6
#define LWAVE  7
#define RWAVE 8


//==================== èˆµæœºåˆ†æ­¥çŠ¶æ€æœºç»“æ„ä½“ ====================
typedef struct {
  int direction;           // å½“å‰åŠ¨ä½œæ–¹å‘
  float Ind_var;           // å½“å‰åŠ¨ä½œè¿›åº¦
  float interval_tims;     // æ­¥è¿›é—´éš”
  int interval_ms;         // æ­¥è¿›å»¶è¿Ÿï¼ˆå·²ä¸ç”¨ï¼‰
  bool in_progress;        // æ˜¯å¦æœ‰åŠ¨ä½œåœ¨è¿›è¡Œ
  bool continuous;         // æ˜¯å¦æŒç»­è¿åŠ¨
  unsigned long last_step_time; // ä¸Šæ¬¡æ­¥è¿›æ—¶é—´
} ServoMotionState;

ServoMotionState servoState = {IDLE, 0, 6, 5, false, false, 0};
//==================== End ====================


// å®šé«˜æ§åˆ¶å‚æ•°
// float targetAltitude = 1.2;          // ç›®æ ‡æ‚¬åœé«˜åº¦ (ç±³)
// float currentAltitude = 0.0;         // å½“å‰é«˜åº¦ (ç±³)
// volatile int pendingUpCompensate = 0; // éé˜»å¡UPè¡¥å¿è®¡æ•°

// å®šé«˜æ§åˆ¶çŠ¶æ€
// bool altitudeHoldEnabled = false;    // å®šé«˜æ¨¡å¼å¼€å…³
// unsigned long lastAltitudeRead = 0;
// const unsigned long altitudeReadInterval = 50;  // 50msè¯»å–ä¸€æ¬¡é«˜åº¦ï¼ˆåŸ100msï¼‰

// å®šé«˜æ§åˆ¶é€»è¾‘
// float altitudeTolerance = 0.2;       // é«˜åº¦å®¹å·® (Â±20cm)
// unsigned long lastAltitudeControl = 0;
// const unsigned long altitudeControlInterval = 200;  // 200msæ§åˆ¶ä¸€æ¬¡

//-------------------------------- Camera pins (XIAOâ€‘S3 Sense OV2640)
static camera_config_t cam_cfg = {
  .pin_pwdn  = -1, .pin_reset = -1,
  .pin_xclk  = 10,
  .pin_sscb_sda = 40, .pin_sscb_scl = 39,
  .pin_d7 = 48, .pin_d6 = 11, .pin_d5 = 12, .pin_d4 = 14,
  .pin_d3 = 16, .pin_d2 = 18, .pin_d1 = 17, .pin_d0 = 15,
  .pin_vsync = 38, .pin_href = 47, .pin_pclk = 13,
  .xclk_freq_hz = 20000000,
  .ledc_timer   = LEDC_TIMER_0,
  .ledc_channel = LEDC_CHANNEL_0,
  .pixel_format = PIXFORMAT_JPEG,
  .frame_size   = FRAMESIZE_SVGA,
  .jpeg_quality = 10,
  .fb_count     = 2,
  .fb_location  = CAMERA_FB_IN_PSRAM,
  .grab_mode    = CAMERA_GRAB_WHEN_EMPTY
};

static httpd_handle_t camera_httpd = NULL;

//-------------------------------- ESP32Servo èˆµæœºæ§åˆ¶ (çŠ¶æ€æœºç‰ˆæœ¬ - çœŸæ­£å¿«é€Ÿå“åº”)
// èˆµæœºå¯¹è±¡ - åŒç¿¼4DOFç»“æ„ (åŸºäºQboåŸç‰ˆæ˜ å°„)
Servo sla, slb, sra, srb;
// sla: å·¦ç¿¼æ‰‘åŠ¨èˆµæœº (æ§åˆ¶å·¦ç¿¼æ‰‘ç¿¼åŠ¨ä½œ)
// slb: å·¦ç¿¼è½¬å‘èˆµæœº (æ§åˆ¶å·¦ç¿¼æ”»è§’/æ–¹å‘)  
// sra: å³ç¿¼æ‰‘åŠ¨èˆµæœº (æ§åˆ¶å³ç¿¼æ‰‘ç¿¼åŠ¨ä½œ)
// srb: å³ç¿¼è½¬å‘èˆµæœº (æ§åˆ¶å³ç¿¼æ”»è§’/æ–¹å‘)

// è“ç‰™å‘½ä»¤æ˜ å°„ - åªä¿ç•™é£è¡Œ/æ¨¡å¼ç›¸å…³å‘½ä»¤
const char* cmdMap[] = {"IDLE", "FWD", "UP", "DOWN", "LEFT", "RIGHT", "BACK", "LWAVE", "RWAVE", "TRACK", "CRUISE", "MANUAL"};
const int CMD_COUNT = 12;

// èˆµæœºå‚æ•° - MG90S
int min_angle = 0, mid_angle = 90, max_angle = 180;
const float servo_step = 5.0; // æ¯æ¬¡æœ€å¤§å˜åŒ–5åº¦

// æ–°å¢ï¼šèˆµæœºå½“å‰è§’åº¦å˜é‡å’Œå¹³æ»‘æ­¥é•¿
float sla_current = 90, slb_current = 90, sra_current = 90, srb_current = 90;

// å¹³æ»‘æ’å€¼å‡½æ•°
float smoothMove(float current, float target, float step) {
  if (abs(target - current) <= step) return target;
  return current + (target > current ? step : -step);
}

// çŠ¶æ€æœºå˜é‡ - ä½¿ç”¨åŸç‰ˆæœ¬çš„å®Œæ•´å¾ªç¯æ–¹å¼
volatile int current_direction = IDLE;
volatile int target_direction = IDLE;
volatile bool direction_changed = false;
volatile bool motion_in_progress = false;
volatile bool stop_motion = false;  // ç«‹å³åœæ­¢æ ‡å¿—
volatile bool continuous_motion = false;  // æŒç»­è¿åŠ¨æ ‡å¿—

// é¿éšœæ§åˆ¶æ ‡å¿—
volatile bool obstacle_avoidance_active = false;  // é¿éšœæ¿€æ´»æ ‡å¿—
volatile bool obstacle_override_command = false;  // é¿éšœæ˜¯å¦è¦†ç›–ç”¨æˆ·å‘½ä»¤

//-------------------------------- AMG8833 Thermal Functions



//-------------------------------- Camera Functions
bool initCamera() {
  Serial.println("ğŸ”§ å¼€å§‹åˆå§‹åŒ–æ‘„åƒå¤´...");
  esp_err_t err = esp_camera_init(&cam_cfg);
  if(err != ESP_OK) {
    Serial.printf("âŒ æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥: 0x%x\n", err);
      return false;
    }
  Serial.println("âœ… æ‘„åƒå¤´åˆå§‹åŒ–æˆåŠŸ");
  
  // æ‘„åƒå¤´é…ç½® - ä½¿ç”¨é‡å®šä¹‰çš„ç±»å‹
  camera_sensor_t *s = esp_camera_sensor_get();
  if (s != NULL) {
    s->set_vflip(s, 1);
    s->set_hmirror(s, 0);
    s->set_quality(s, 10);
    Serial.println("âœ… æ‘„åƒå¤´é…ç½®å®Œæˆ");
  }
  
  return true;
}

void readCameraFrame() {
  camera_fb_t *fb = esp_camera_fb_get();
  if (!fb) {
    Serial.println("âŒ è·å–æ‘„åƒå¤´å¸§å¤±è´¥");
    return;
  }
  
  // å¤„ç†æ‘„åƒå¤´å¸§æ•°æ®
  // ...
  
  esp_camera_fb_return(fb);
  }

//-------------------------------- ESP32Servo èˆµæœºæ§åˆ¶ (çŠ¶æ€æœºç‰ˆæœ¬ - çœŸæ­£å¿«é€Ÿå“åº”)
// èˆµæœºå¯¹è±¡ - åŒç¿¼4DOFç»“æ„ (åŸºäºQboåŸç‰ˆæ˜ å°„)
Servo sla, slb, sra, srb;
// sla: å·¦ç¿¼æ‰‘åŠ¨èˆµæœº (æ§åˆ¶å·¦ç¿¼æ‰‘ç¿¼åŠ¨ä½œ)
// slb: å·¦ç¿¼è½¬å‘èˆµæœº (æ§åˆ¶å·¦ç¿¼æ”»è§’/æ–¹å‘)  
// sra: å³ç¿¼æ‰‘åŠ¨èˆµæœº (æ§åˆ¶å³ç¿¼æ‰‘ç¿¼åŠ¨ä½œ)
// srb: å³ç¿¼è½¬å‘èˆµæœº (æ§åˆ¶å³ç¿¼æ”»è§’/æ–¹å‘)

// èˆµæœºåˆå§‹åŒ– - é’ˆå¯¹MG90Sä¼˜åŒ–
void servo_attach() {
  Serial.println("ğŸ”§ å¼€å§‹åˆå§‹åŒ–MG90Sèˆµæœº (çŠ¶æ€æœºç‰ˆæœ¬)...");
  sla.attach(3, 1000, 2000);  // MG90Sæ¨èè„‰å®½èŒƒå›´
  sla.write(mid_angle);
  Serial.println("âœ… sla (å¼•è„š 3) å·¦ç¿¼æ‰‘åŠ¨èˆµæœºåˆå§‹åŒ–å®Œæˆ");
  slb.attach(4, 1000, 2000);
  slb.write(mid_angle);
  Serial.println("âœ… slb (å¼•è„š 4) å·¦ç¿¼è½¬å‘èˆµæœºåˆå§‹åŒ–å®Œæˆ");
  sra.attach(7, 1000, 2000);
  sra.write(mid_angle);
  Serial.println("âœ… sra (å¼•è„š 7) å³ç¿¼æ‰‘åŠ¨èˆµæœºåˆå§‹åŒ–å®Œæˆ");
  srb.attach(8, 1000, 2000);
  srb.write(mid_angle);
  Serial.println("âœ… srb (å¼•è„š 8) å³ç¿¼è½¬å‘èˆµæœºåˆå§‹åŒ–å®Œæˆ");
  Serial.println("ğŸ”§ MG90Sèˆµæœºåˆå§‹åŒ–å®Œæˆ - è¶…å¿«å“åº”æ¨¡å¼å¯ç”¨");
  Serial.println("ğŸ“Š èˆµæœºå‚æ•°: 180Â°èŒƒå›´, 0.08~0.10s/60Â°, 2.0~2.5kgÂ·cm, é‡‘å±é½¿è½®, æ¨èè„‰å®½1000-2000us");
}

void servo_detach() {
  sla.detach();
  slb.detach();
  sra.detach();
  srb.detach();
}

// æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åªåŒ…å«åˆæ³•å­—ç¬¦
bool isValidCommand(const char* input, size_t len) {
  for (size_t i = 0; i < len; i++) {
    char c = input[i];
    // å…è®¸å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ã€å†’å·å’Œé€—å·ï¼ˆç”¨äºLEDå‘½ä»¤ï¼‰
    if (!isAlpha(c) && !isDigit(c) && c != '_' && c != ':' && c != ',') {
      return false;
    }
  }
  return true;
}

// ç«‹å³è®¾ç½®èˆµæœºåˆ°IDLEä½ç½® - è¶…å¿«å“åº”ç‰ˆæœ¬
void setServoIdle() {
  // å¹³æ»‘æ’å€¼å›ä¸­ä½
  bool all_ready = false;
  while (!all_ready) {
    all_ready = true;
    sla_current = smoothMove(sla_current, mid_angle, servo_step);
    slb_current = smoothMove(slb_current, mid_angle, servo_step);
    sra_current = smoothMove(sra_current, mid_angle, servo_step);
    srb_current = smoothMove(srb_current, mid_angle, servo_step);
    sla.write(sla_current);
    slb.write(slb_current);
    sra.write(sra_current);
    srb.write(srb_current);
    if (sla_current != mid_angle || slb_current != mid_angle ||
        sra_current != mid_angle || srb_current != mid_angle) {
      all_ready = false;
    }
    vTaskDelay(10 / portTICK_PERIOD_MS); // å’Œå…¶ä»–åŠ¨ä½œä¸€è‡´
  }
  Serial.println("ğŸ›‘ èˆµæœºå¹³æ»‘å›ä¸­ä½å®Œæˆ");
}

// å¼ºåˆ¶ç«‹å³åœæ­¢æ‰€æœ‰åŠ¨ä½œ
void forceStopMotion() {
  stop_motion = true;
  motion_in_progress = false;
  continuous_motion = false;  // åœæ­¢æŒç»­è¿åŠ¨
  current_direction = IDLE;
  target_direction = IDLE;
  direction_changed = false;
  setServoIdle();
  Serial.println("âš¡ å¼ºåˆ¶ç«‹å³åœæ­¢æ‰€æœ‰åŠ¨ä½œ");
}


//-------------------------------- HTTP Server Functions - TEMPORARILY DISABLED
/*
static esp_err_t index_handler(httpd_req_t *req) {
  const char* html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skyris WebSocket Control</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f0f0f0; }
        .container { max-width: 1200px; margin: 0 auto; }
        .panel { background: white; border-radius: 10px; padding: 20px; margin: 10px 0; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-width: 300px; margin: 0 auto; }
        .btn { padding: 15px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; transition: all 0.3s; }
        .btn:hover { transform: scale(1.05); }
        .flight-btn { background: #4CAF50; color: white; }
        .flight-btn:hover { background: #45a049; }
        .led-btn { background: #2196F3; color: white; margin: 5px; }
        .led-btn:hover { background: #1976D2; }
        .status { padding: 10px; border-radius: 5px; margin: 10px 0; }
        .connected { background: #d4edda; color: #155724; }
        .disconnected { background: #f8d7da; color: #721c24; }
        .thermal-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px; max-width: 400px; margin: 20px auto; }
        .thermal-cell { width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 10px; border-radius: 3px; }
        .color-picker { margin: 10px; }
        .preset-colors { display: flex; gap: 10px; margin: 10px 0; }
        .color-preset { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 2px solid #ccc; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš Skyris WebSocket Control</h1>
        
        <div class="panel">
            <h2>ğŸ”Œ Connection Status</h2>
            <div id="status" class="status disconnected">Disconnected</div>
        </div>
        
        <div class="panel">
            <h2>ğŸ® Flight Control</h2>
            <div class="grid">
                <div></div>
                <button class="btn flight-btn" onclick="sendCommand('UP')">â¬†ï¸ UP</button>
                <div></div>
                <button class="btn flight-btn" onclick="sendCommand('LEFT')">â¬…ï¸ LEFT</button>
                <button class="btn flight-btn" onclick="sendCommand('IDLE')" style="background: #f44336;">ğŸ›‘ STOP</button>
                <button class="btn flight-btn" onclick="sendCommand('RIGHT')">â¡ï¸ RIGHT</button>
                <button class="btn flight-btn" onclick="sendCommand('BACK')">â¬‡ï¸ BACK</button>
                <button class="btn flight-btn" onclick="sendCommand('DOWN')">â¬‡ï¸ DOWN</button>
                <button class="btn flight-btn" onclick="sendCommand('FWD')">â¬†ï¸ FWD</button>
            </div>
        </div>
        
        <div class="panel">
            <h2>ğŸ¯ Flight Mode</h2>
            <div>
                <button class="btn led-btn" onclick="sendCommand('MANUAL')" style="background: #FF9800;">ğŸ® Manual</button>
                <button class="btn led-btn" onclick="sendCommand('TRACK')" style="background: #E91E63;">ğŸ”¥ Track</button>
                <button class="btn led-btn" onclick="sendCommand('CRUISE')" style="background: #9C27B0;">ğŸ² Cruise</button>
                <button class="btn led-btn" onclick="sendCommand('ALTITUDE')" style="background: #4CAF50;">ğŸ“ Altitude Hold</button>
            </div>
            <div id="currentMode" style="margin-top: 10px; font-weight: bold;">Current Mode: Manual</div>
            <div style="margin: 10px 0; padding: 10px; background: #e8f5e8; border-radius: 5px; font-size: 14px;">
                ğŸ“ <strong>å®šé«˜æ¨¡å¼:</strong> è‡ªåŠ¨ä¿æŒ1.5ç±³ä»¥ä¸Šæ‚¬åœé«˜åº¦ï¼Œä¸å…¶ä»–æ¨¡å¼å…¼å®¹
            </div>
            <div style="margin-top: 10px;">
                <button class="btn led-btn" onclick="resetBMP388L()" style="background: #FF5722;">ğŸ”§ é‡ç½®BMP388L</button>
                <div id="bmp388Status" style="margin-top: 5px; font-size: 12px; color: #666;">ç‚¹å‡»é‡ç½®æŒ‰é’®å¯è§£å†³æ°”å‹è®¡æ•°æ®å¡æ­»é—®é¢˜</div>
            </div>
        </div>
        
        <div class="panel">
            <h2>ğŸŒˆ LED Control</h2>
            <div>
                <button class="btn led-btn" onclick="sendCommand('LED_BREATH')">ğŸ« Breathing</button>
                <button class="btn led-btn" onclick="sendCommand('LED_RAINBOW')">ğŸŒˆ Rainbow</button>
                <button class="btn led-btn" onclick="sendCommand('LED_SOLID')">ğŸ’¡ Solid</button>
                <button class="btn led-btn" onclick="sendCommand('LED_OFF')">âš« Off</button>
            </div>
            <div style="margin: 10px 0; padding: 10px; background: #e8f5e8; border-radius: 5px; font-size: 14px;">
                ğŸ’¡ <strong>æç¤º:</strong> å‘¼å¸ç¯æ¨¡å¼ä½¿ç”¨å½“å‰é€‰æ‹©çš„é¢œè‰²ï¼Œå»ºè®®ä½¿ç”¨è¾ƒäº®çš„é¢œè‰²ä»¥è·å¾—æœ€ä½³æ•ˆæœ
            </div>
            <div class="color-picker">
                <label>Custom Color: </label>
                <input type="color" id="colorPicker" value="#ffffff" onchange="updateColor()">
            </div>
            <div class="preset-colors">
                <div class="color-preset" style="background: red;" onclick="setPresetColor(255,0,0)"></div>
                <div class="color-preset" style="background: green;" onclick="setPresetColor(0,255,0)"></div>
                <div class="color-preset" style="background: blue;" onclick="setPresetColor(0,0,255)"></div>
                <div class="color-preset" style="background: yellow;" onclick="setPresetColor(255,255,0)"></div>
                <div class="color-preset" style="background: purple;" onclick="setPresetColor(255,0,255)"></div>
                <div class="color-preset" style="background: cyan;" onclick="setPresetColor(0,255,255)"></div>
                <div class="color-preset" style="background: white;" onclick="setPresetColor(255,255,255)"></div>
            </div>
        </div>
        
        <div class="panel">
            <h2>ğŸ”¥ Thermal Imaging</h2>
            <div id="thermalGrid" class="thermal-grid"></div>
        </div>
        
        <div class="panel">
            <h2>ğŸ“¹ Camera Stream</h2>
            <img src="/stream" style="max-width: 100%; border-radius: 10px;">
        </div>
    </div>

    <script>
        let ws;
        let wsConnected = false;
        
        function connectWebSocket() {
            ws = new WebSocket('ws://' + window.location.hostname + ':81');
            
            ws.onopen = function() {
                wsConnected = true;
                document.getElementById('status').className = 'status connected';
                document.getElementById('status').textContent = 'Connected to WebSocket';
                console.log('WebSocket connected');
                
                // è¯·æ±‚å½“å‰é¿éšœçŠ¶æ€ï¼ˆé€šè¿‡å‘é€çŠ¶æ€æŸ¥è¯¢å‘½ä»¤ï¼‰
                setTimeout(() => {
                    console.log('Requesting initial obstacle avoidance status...');
                    // å‘é€ä¸€ä¸ªçŠ¶æ€æŸ¥è¯¢å‘½ä»¤ï¼ŒESP32ä¼šåœ¨ä¸‹æ¬¡çƒ­æˆåƒæ•°æ®ä¸­åŒ…å«çŠ¶æ€
                }, 1000);
            };
            
            
            ws.onclose = function() {
                wsConnected = false;
                document.getElementById('status').className = 'status disconnected';
                document.getElementById('status').textContent = 'Disconnected - Reconnecting...';
                console.log('WebSocket disconnected');
                setTimeout(connectWebSocket, 3000);
            };
            
            ws.onmessage = function(event) {
                console.log('Received:', event.data);
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'thermal') {
                        console.log('WebSocket thermal data received:', data.pixels.length, 'pixels');
                        updateThermalGrid(data.pixels);
                        // æ›´æ–°é¿éšœçŠ¶æ€ï¼ˆå¦‚æœåŒ…å«åœ¨çƒ­æˆåƒæ•°æ®ä¸­ï¼‰
                        if (data.avoidance_active !== undefined) {
                            updateObstacleStatus({
                                avoidance_active: data.avoidance_active,
                                distance: data.tof_distance,
                                sensor_available: data.tof_available
                            });
                        }
                    } else if (data.type === 'mode') {
                        document.getElementById('currentMode').textContent = 'Current Mode: ' + data.mode;
                    } else if (data.type === 'status') {
                        console.log('Status update:', data);
                    } else if (data.type === 'response') {
                        console.log('Command response:', data);
                        // å¤„ç†BMP388Lé‡ç½®å“åº”
                        if (data.command === 'RESET_BMP388L') {
                            const statusDiv = document.getElementById('bmp388Status');
                            if (data.status === 'success') {
                                statusDiv.textContent = 'âœ… BMP388Lé‡ç½®æˆåŠŸï¼';
                                statusDiv.style.color = '#4CAF50';
                                setTimeout(() => {
                                    statusDiv.textContent = 'ç‚¹å‡»é‡ç½®æŒ‰é’®å¯è§£å†³æ°”å‹è®¡æ•°æ®å¡æ­»é—®é¢˜';
                                    statusDiv.style.color = '#666';
                                }, 3000);
    } else {
                                statusDiv.textContent = 'âŒ BMP388Lé‡ç½®å¤±è´¥ï¼Œè¯·é‡è¯•';
                                statusDiv.style.color = '#f44336';
                                setTimeout(() => {
                                    statusDiv.textContent = 'ç‚¹å‡»é‡ç½®æŒ‰é’®å¯è§£å†³æ°”å‹è®¡æ•°æ®å¡æ­»é—®é¢˜';
                                    statusDiv.style.color = '#666';
                                }, 3000);
                            }
                        }
                    }
                } catch (e) {
                    console.log('Non-JSON message:', event.data);
                }
            };
            
            ws.onerror = function(error) {
                console.log('WebSocket error:', error);
            };
        }
        
        function sendCommand(command) {
            if (wsConnected && ws.readyState === WebSocket.OPEN) {
                ws.send(command);
                console.log('Sent command:', command);
      } else {
                console.log('WebSocket not connected');
            }
        }
        
        function resetBMP388L() {
            if (wsConnected && ws.readyState === WebSocket.OPEN) {
                const statusDiv = document.getElementById('bmp388Status');
                statusDiv.textContent = 'ğŸ”„ æ­£åœ¨resetBMP388L...';
                statusDiv.style.color = '#FF9800';
                
                ws.send('RESET_BMP388L');
                console.log('Sent BMP388L reset command');
            } else {
                alert('WebSocketæœªè¿æ¥ï¼Œæ— æ³•æ‰§è¡Œé‡ç½®æ“ä½œ');
            }
        }
        
        function updateColor() {
            const color = document.getElementById('colorPicker').value;
            const r = parseInt(color.substr(1, 2), 16);
            const g = parseInt(color.substr(3, 2), 16);
            const b = parseInt(color.substr(5, 2), 16);
            sendCommand(`LED_COLOR:${r},${g},${b}`);
        }
        
        function setPresetColor(r, g, b) {
            sendCommand(`LED_COLOR:${r},${g},${b}`);
            const hex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            document.getElementById('colorPicker').value = hex;
        }
        
        function updateThermalGrid(pixels) {
            const grid = document.getElementById('thermalGrid');
            grid.innerHTML = '';
            
            for (let i = 0; i < 64; i++) {
                const cell = document.createElement('div');
                cell.className = 'thermal-cell';
                const temp = pixels[i];
                cell.textContent = temp.toFixed(1);
                
                // Color coding based on temperature
                if (temp > 30) cell.style.background = '#ff4444';
                else if (temp > 25) cell.style.background = '#ffaa44';
                else if (temp > 20) cell.style.background = '#ffff44';
                else cell.style.background = '#4444ff';
                
                grid.appendChild(cell);
            }
        }
        
        // Initialize thermal grid
        for (let i = 0; i < 64; i++) {
            const cell = document.createElement('div');
            cell.className = 'thermal-cell';
            cell.textContent = '20.0';
            cell.style.background = '#4444ff';
            document.getElementById('thermalGrid').appendChild(cell);
        }
        
        // Connect on page load
        connectWebSocket();
        
        // Update thermal data every 5 seconds as backup (WebSocket is primary)
        setInterval(() => {
            // Only use HTTP as backup if WebSocket is not connected
            if (!wsConnected) {
                console.log('WebSocket disconnected, fetching thermal data via HTTP...');
                fetch('/thermal')
                    .then(response => {
                        console.log('Thermal response status:', response.status);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log('HTTP thermal data received:', data);
                        updateThermalGrid(data.pixels);
                    })
                    .catch(error => {
                        console.error('Thermal data fetch error:', error);
                    });
            }
        }, 5000);
    </script>
</body>
</html>
)rawliteral";
  
  httpd_resp_set_type(req, "text/html");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  return httpd_resp_send(req, html, strlen(html));
}

static esp_err_t thermal_handler(httpd_req_t *req) {
  Serial.println("ğŸ”¥ğŸ”¥ğŸ”¥ æ”¶åˆ°çƒ­æˆåƒæ•°æ®è¯·æ±‚ ğŸ”¥ğŸ”¥ğŸ”¥");
  Serial.printf("ğŸ“ è¯·æ±‚URI: %s\n", req->uri);
  Serial.printf("ğŸ“ è¯·æ±‚æ–¹æ³•: %d\n", req->method);
  
  if (!thermal_sensor_available) {
    Serial.println("âŒ çƒ­æˆåƒä¼ æ„Ÿå™¨ä¸å¯ç”¨");
    httpd_resp_send_404(req);
    return ESP_FAIL;
  }
  
  Serial.println("ğŸ“Š å¼€å§‹è¯»å–çƒ­æˆåƒæ•°æ®...");
  readThermalData();
  
  String json = "{\"pixels\":[";
  for (int i = 0; i < AMG88xx_PIXEL_ARRAY_SIZE; i++) {
    if (i > 0) json += ",";
    json += String(thermal_pixels[i], 1);
  }
  json += "],\"max_temp\":" + String(max_temp, 1);
  json += ",\"heat_x\":" + String(heat_source_x);
  json += ",\"heat_y\":" + String(heat_source_y) + "}";
  
  Serial.printf("ğŸ“¤ å‘é€çƒ­æˆåƒJSONé•¿åº¦: %d\n", json.length());
  Serial.printf("ğŸ“¤ JSONå‰100å­—ç¬¦: %s\n", json.substring(0, 100).c_str());
  
  httpd_resp_set_type(req, "application/json");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  esp_err_t result = httpd_resp_send(req, json.c_str(), json.length());
  
  if (result == ESP_OK) {
    Serial.println("âœ… çƒ­æˆåƒæ•°æ®å‘é€æˆåŠŸ");
  } else {
    Serial.printf("âŒ çƒ­æˆåƒæ•°æ®å‘é€å¤±è´¥: %d\n", result);
  }
  
  return result;
}

static esp_err_t mode_handler(httpd_req_t *req) {
  size_t buf_len = httpd_req_get_url_query_len(req) + 1;
  if (buf_len > 1) {
    char* buf = (char*)malloc(buf_len);
    if (httpd_req_get_url_query_str(req, buf, buf_len) == ESP_OK) {
      char param[32];
      if (httpd_query_key_value(buf, "mode", param, sizeof(param)) == ESP_OK) {
        String mode = String(param);
        mode.toUpperCase();
        processCommand(mode);
      }
    }
    free(buf);
  }
  
  httpd_resp_set_type(req, "text/plain");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  return httpd_resp_send(req, "OK", 2);
}

static esp_err_t capture_handler(httpd_req_t *req) {
  camera_fb_t *fb = esp_camera_fb_get();
  if (!fb) {
    httpd_resp_send_500(req);
    return ESP_FAIL;
  }
  
  httpd_resp_set_type(req, "image/jpeg");
  httpd_resp_set_hdr(req, "Content-Disposition", "inline; filename=capture.jpg");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  
  esp_err_t res = httpd_resp_send(req, (const char *)fb->buf, fb->len);
  esp_camera_fb_return(fb);
  
  return res;
}

#define PART_BOUNDARY "123456789000000000000987654321"
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" PART_BOUNDARY;
static const char* _STREAM_BOUNDARY = "\r\n--" PART_BOUNDARY "\r\n";
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

static esp_err_t stream_handler(httpd_req_t *req) {
  Serial.println("ğŸ“¹ æ”¶åˆ°è§†é¢‘æµè¯·æ±‚");
  
  camera_fb_t *fb = NULL;
  esp_err_t res = ESP_OK;
  char part_buf[128];
  
  res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if (res != ESP_OK) {
    Serial.printf("âŒ è®¾ç½®å“åº”ç±»å‹å¤±è´¥: %d\n", res);
    return res;
  }
  
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  httpd_resp_set_hdr(req, "Cache-Control", "no-cache, no-store, must-revalidate");
  httpd_resp_set_hdr(req, "Pragma", "no-cache");
  httpd_resp_set_hdr(req, "Expires", "0");
  Serial.println("âœ… è§†é¢‘æµå“åº”å¤´è®¾ç½®å®Œæˆ");
  
  int frame_count = 0;
  unsigned long last_frame_time = millis();
  
  while (true) {
    unsigned long frame_start = millis();
    
    fb = esp_camera_fb_get();
    if (!fb) {
      Serial.printf("âŒ è·å–æ‘„åƒå¤´å¸§å¤±è´¥ (å¸§#%d)\n", frame_count);
      res = ESP_FAIL;
      break;
    }
    
    // å‡å°‘è°ƒè¯•è¾“å‡ºé¢‘ç‡ï¼Œé¿å…å½±å“æ€§èƒ½
    if (frame_count % 100 == 0) {  // æ¯100å¸§è¾“å‡ºä¸€æ¬¡è°ƒè¯•ä¿¡æ¯
      unsigned long fps = 1000 / (millis() - last_frame_time + 1);
      Serial.printf("ğŸ“¹ è§†é¢‘æµæ­£å¸¸ - å¸§#%d, å¤§å°=%d bytes, FPSâ‰ˆ%lu\n", frame_count, fb->len, fps);
      last_frame_time = millis();
    }
    
    // å‘é€è¾¹ç•Œ
    if (res == ESP_OK) {
      res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    }
    
    // å‘é€å¤´éƒ¨
    if (res == ESP_OK) {
      size_t hlen = snprintf(part_buf, 128, _STREAM_PART, fb->len);
      res = httpd_resp_send_chunk(req, part_buf, hlen);
    }
    
    // å‘é€å›¾åƒæ•°æ®
    if (res == ESP_OK) {
      res = httpd_resp_send_chunk(req, (const char *)fb->buf, fb->len);
    }
    
    esp_camera_fb_return(fb);
    
    if (res != ESP_OK) {
      Serial.printf("âŒ è§†é¢‘æµå‘é€å¤±è´¥: %d (å¸§#%d)\n", res, frame_count);
      break;
    }
    
    frame_count++;
    
    // åŠ¨æ€å¸§ç‡æ§åˆ¶ - æ ¹æ®å¤„ç†æ—¶é—´è°ƒæ•´å»¶è¿Ÿ
    unsigned long frame_time = millis() - frame_start;
    if (frame_time < 66) {  // ç›®æ ‡15FPS (66ms per frame)
      vTaskDelay(pdMS_TO_TICKS(66 - frame_time));
    } else {
      vTaskDelay(pdMS_TO_TICKS(10));  // æœ€å°å»¶è¿Ÿï¼Œé¿å…é˜»å¡å…¶ä»–ä»»åŠ¡
    }
  }
  
  Serial.printf("ğŸ“¹ è§†é¢‘æµç»“æŸ - æ€»å¸§æ•°: %d\n", frame_count);
  return res;
}
*/

//-------------------------------- WiFi Station Mode Functions
bool connectWiFi() {
  Serial.println("ğŸ”Œ å¼€å§‹è¿æ¥WiFiç½‘ç»œ...");
  Serial.printf("ğŸ“¡ ç›®æ ‡ç½‘ç»œ: %s\n", WIFI_SSID);
  
  // è®¾ç½®WiFiä¸ºStationæ¨¡å¼
  WiFi.mode(WIFI_STA);
  WiFi.disconnect(true);  // æ¸…é™¤ä¹‹å‰çš„è¿æ¥
  delay(1000);
  
  // å¼€å§‹è¿æ¥
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  
  unsigned long startTime = millis();
  int dots = 0;
  
  Serial.print("ğŸ”„ è¿æ¥ä¸­");
  
  // ç­‰å¾…è¿æ¥ï¼Œæ˜¾ç¤ºè¿›åº¦
  while (WiFi.status() != WL_CONNECTED && (millis() - startTime) < WIFI_TIMEOUT) {
    delay(500);
    Serial.print(".");
    dots++;
    
    // æ¯10ä¸ªç‚¹æ¢è¡Œ
    if (dots % 10 == 0) {
      Serial.printf(" (%luç§’)\nğŸ”„ ç»§ç»­è¿æ¥", (millis() - startTime) / 1000);
    }
    
    // æ¯5ç§’æ˜¾ç¤ºè¿æ¥çŠ¶æ€
    if (dots % 10 == 0) {
      switch (WiFi.status()) {
        case WL_IDLE_STATUS:
          Serial.print(" [ç©ºé—²]");
          break;
        case WL_NO_SSID_AVAIL:
          Serial.print(" [ç½‘ç»œä¸å¯ç”¨]");
          break;
        case WL_SCAN_COMPLETED:
          Serial.print(" [æ‰«æå®Œæˆ]");
          break;
        case WL_CONNECT_FAILED:
          Serial.print(" [è¿æ¥å¤±è´¥]");
          break;
        case WL_CONNECTION_LOST:
          Serial.print(" [è¿æ¥ä¸¢å¤±]");
          break;
        case WL_DISCONNECTED:
          Serial.print(" [å·²æ–­å¼€]");
          break;
        default:
          Serial.printf(" [çŠ¶æ€:%d]", WiFi.status());
          break;
      }
    }
  }
  
  Serial.println(); // æ¢è¡Œ
  
  if (WiFi.status() == WL_CONNECTED) {
    device_ip = WiFi.localIP().toString();
    Serial.println("âœ… WiFiè¿æ¥æˆåŠŸ!");
    Serial.printf("ğŸ“ æœ¬åœ°IPåœ°å€: %s\n", device_ip.c_str());
    Serial.printf("ğŸ“¶ ä¿¡å·å¼ºåº¦: %d dBm\n", WiFi.RSSI());
    Serial.printf("ğŸŒ ç½‘å…³: %s\n", WiFi.gatewayIP().toString().c_str());
    Serial.printf("ğŸŒ å­ç½‘æ©ç : %s\n", WiFi.subnetMask().toString().c_str());
    Serial.printf("ğŸŒ DNS: %s\n", WiFi.dnsIP().toString().c_str());
    
    return true;
  } else {
    Serial.println("âŒ WiFiè¿æ¥å¤±è´¥!");
    Serial.printf("â° è¿æ¥è¶…æ—¶ (%luç§’)\n", WIFI_TIMEOUT / 1000);
    
    // æ˜¾ç¤ºè¯¦ç»†çš„å¤±è´¥åŸå› 
    switch (WiFi.status()) {
      case WL_NO_SSID_AVAIL:
        Serial.printf("ğŸ“¡ é”™è¯¯: æ‰¾ä¸åˆ°ç½‘ç»œ '%s'\n", WIFI_SSID);
        Serial.println("ğŸ’¡ è¯·æ£€æŸ¥:");
        Serial.println("   - SSIDæ˜¯å¦æ­£ç¡®");
        Serial.println("   - è·¯ç”±å™¨æ˜¯å¦å¼€å¯");
        Serial.println("   - è·ç¦»æ˜¯å¦è¿‡è¿œ");
        break;
      case WL_CONNECT_FAILED:
        Serial.println("ğŸ” é”™è¯¯: è¿æ¥å¤±è´¥");
        Serial.println("ğŸ’¡ è¯·æ£€æŸ¥:");
        Serial.println("   - WiFiå¯†ç æ˜¯å¦æ­£ç¡®");
        Serial.println("   - ç½‘ç»œæ˜¯å¦å…è®¸æ–°è®¾å¤‡è¿æ¥");
        break;
      case WL_CONNECTION_LOST:
        Serial.println("ğŸ“¶ é”™è¯¯: è¿æ¥ä¸¢å¤±");
        Serial.println("ğŸ’¡ ä¿¡å·å¯èƒ½ä¸ç¨³å®š");
        break;
      default:
        Serial.printf("â“ æœªçŸ¥é”™è¯¯ (çŠ¶æ€ç : %d)\n", WiFi.status());
        break;
    }
    
    return false;
  }
}

void checkWiFiConnection() {
  static unsigned long lastCheck = 0;
  static bool was_connected = false;
  
  // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡è¿æ¥çŠ¶æ€
  if (millis() - lastCheck > 30000) {
    bool is_connected = (WiFi.status() == WL_CONNECTED);
    
    if (is_connected && !was_connected) {
      // é‡æ–°è¿æ¥æˆåŠŸ
      device_ip = WiFi.localIP().toString();
      Serial.println("ğŸ”„ WiFié‡æ–°è¿æ¥æˆåŠŸ!");
      Serial.printf("ğŸ“ IPåœ°å€: %s\n", device_ip.c_str());
    } else if (!is_connected && was_connected) {
      // è¿æ¥ä¸¢å¤±
      Serial.println("âš ï¸ WiFiè¿æ¥ä¸¢å¤±ï¼Œå°è¯•é‡è¿...");
      
      // å°è¯•é‡è¿
      WiFi.disconnect();
      delay(1000);
      WiFi.begin(WIFI_SSID, WIFI_PASS);
      
      // ç­‰å¾…é‡è¿ï¼ˆè¾ƒçŸ­è¶…æ—¶ï¼‰
      unsigned long reconnect_start = millis();
      while (WiFi.status() != WL_CONNECTED && (millis() - reconnect_start) < 10000) {
        delay(500);
        Serial.print(".");
      }
      
      if (WiFi.status() == WL_CONNECTED) {
        device_ip = WiFi.localIP().toString();
        Serial.println("\nâœ… WiFié‡è¿æˆåŠŸ!");
        Serial.printf("ğŸ“ æ–°IPåœ°å€: %s\n", device_ip.c_str());
      } else {
        Serial.println("\nâŒ WiFié‡è¿å¤±è´¥");
        device_ip = "";
      }
    } else if (is_connected) {
      // è¿æ¥æ­£å¸¸ï¼Œå®šæœŸæŠ¥å‘Šä¿¡å·å¼ºåº¦
      static int report_count = 0;
      if (++report_count >= 10) {  // æ¯5åˆ†é’ŸæŠ¥å‘Šä¸€æ¬¡
        Serial.printf("ğŸ“¶ WiFiè¿æ¥æ­£å¸¸ - IP: %s, ä¿¡å·: %d dBm\n", 
                      device_ip.c_str(), WiFi.RSSI());
        report_count = 0;
      }
    }
    
    was_connected = is_connected;
    lastCheck = millis();
  }
}

void startWiFiStation() {
  Serial.println("ğŸŒ å¯åŠ¨WiFi Stationæ¨¡å¼...");
  Serial.printf("ğŸ“ é…ç½®ä¿¡æ¯:\n");
  Serial.printf("   SSID: %s\n", WIFI_SSID);
  Serial.printf("   å¯†ç : %s\n", strlen(WIFI_PASS) > 0 ? "å·²è®¾ç½®" : "æœªè®¾ç½®");
  Serial.printf("   è¶…æ—¶: %dç§’\n", WIFI_TIMEOUT / 1000);
  
  if (connectWiFi()) {
    Serial.println("ğŸ‰ WiFi Stationæ¨¡å¼å¯åŠ¨æˆåŠŸ!");
  } else {
    Serial.println("ğŸ’¥ WiFi Stationæ¨¡å¼å¯åŠ¨å¤±è´¥!");
    Serial.println("ğŸ“± è®¾å¤‡å°†ç»§ç»­ä»¥ç¦»çº¿æ¨¡å¼è¿è¡Œ");
    Serial.println("ğŸ”§ è¯·æ£€æŸ¥WiFié…ç½®å¹¶é‡å¯è®¾å¤‡");
  }
}

//-------------------------------- WebSocket Functions
void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
  switch(type) {
    case WStype_DISCONNECTED:
      Serial.printf("ğŸ”Œ WebSocketå®¢æˆ·ç«¯ %u æ–­å¼€è¿æ¥\n", num);
      websocket_connected = false;
      break;
      
    case WStype_CONNECTED:
      {
        IPAddress ip = webSocket.remoteIP(num);
        Serial.printf("ğŸ”Œ WebSocketå®¢æˆ·ç«¯ %u è¿æ¥: %s\n", num, ip.toString().c_str());
        websocket_connected = true;
        
        // å‘é€åˆå§‹çŠ¶æ€
        String status = "{\"type\":\"status\",\"connected\":true}";
        webSocket.sendTXT(num, status);
      }
      break;
      
    case WStype_TEXT:
      {
        String command = String((char*)payload);
        Serial.printf("ğŸ“¨ WebSocketæ”¶åˆ°å‘½ä»¤: %s\n", command.c_str());
        processCommand(command);
        
        // å‘é€ç¡®è®¤
        String response = "{\"type\":\"response\",\"command\":\"" + command + "\",\"status\":\"ok\"}";
        webSocket.sendTXT(num, response);
      }
      break;
      
    default:
      break;
  }
}

void initWebSocket() {
  webSocket.begin();
  webSocket.onEvent(webSocketEvent);
  Serial.println("âœ… WebSocketæœåŠ¡å™¨å¯åŠ¨ (ç«¯å£81)");
}

void processCommand(String command) {
  command.trim();
  command.toUpperCase();
  Serial.printf("ğŸ® å¤„ç†å‘½ä»¤: %s\n", command.c_str());
  // æŸ¥æ‰¾å‘½ä»¤ç´¢å¼•
  int cmd_index = -1;
  for (int i = 0; i < CMD_COUNT; i++) {
    if (command.equals(cmdMap[i])) {
      cmd_index = i;
      break;
    }
  }
  if (cmd_index == -1) {
    Serial.printf("âŒ æœªçŸ¥å‘½ä»¤: %s\n", command.c_str());
    return;
  }
  // å¤„ç†ä¸åŒç±»å‹çš„å‘½ä»¤
  if (cmd_index >= 0 && cmd_index <= 8) {
    // é£è¡Œæ§åˆ¶å‘½ä»¤
    if (cmd_index == IDLE) {
      forceStopMotion();
    } else {
      target_direction = cmd_index;
      direction_changed = true;
      continuous_motion = true;
      Serial.printf("âš¡ è®¾ç½®é£è¡Œæ–¹å‘: %s (æŒç»­è¿åŠ¨)\n", cmdMap[cmd_index]);
    }
  } else if (cmd_index >= 9 && cmd_index <= 11) {
    // é£è¡Œæ¨¡å¼å‘½ä»¤
    if (cmd_index == 9) flight_mode = TRACK_MODE;      // TRACK
    else if (cmd_index == 10) flight_mode = CRUISE_MODE; // CRUISE
    else if (cmd_index == 11) flight_mode = MANUAL_MODE; // MANUAL
    const char* mode_names[] = {"æ‰‹åŠ¨", "è¿½è¸ª", "å·¡èˆª"};
    Serial.printf("ğŸ¯ é£è¡Œæ¨¡å¼åˆ‡æ¢: %s\n", mode_names[flight_mode]);
    // å‘é€æ¨¡å¼çŠ¶æ€åˆ°WebSocketå®¢æˆ·ç«¯
    String mode_response = "{\"type\":\"mode\",\"mode\":\"" + String(mode_names[flight_mode]) + "\"}";
    webSocket.broadcastTXT(mode_response);
  }
}

//-------------------------------- Arduino entry
void setup(){
  Serial.begin(115200);
  delay(500);
  Serial.println("âš¡ å¯åŠ¨Skyris WiFi Stationç‰ˆæœ¬...");
  
  // æ£€æŸ¥PSRAM
  if (!psramFound()) {
    Serial.println("âš ï¸ æœªæ£€æµ‹åˆ°PSRAM - ä½¿ç”¨DRAMæ¨¡å¼");
    cam_cfg.fb_location = CAMERA_FB_IN_DRAM;
    cam_cfg.frame_size = FRAMESIZE_VGA;
    cam_cfg.jpeg_quality = 15;
  }
  
  // è¿æ¥WiFi (Stationæ¨¡å¼)
  startWiFiStation();
  delay(200);
  
  // åªæœ‰åœ¨WiFiè¿æ¥æˆåŠŸåæ‰ç»§ç»­åˆå§‹åŒ–æœåŠ¡å™¨
  if (WiFi.status() == WL_CONNECTED) {
    // åˆå§‹åŒ–æ‘„åƒå¤´
    esp_err_t err = esp_camera_init(&cam_cfg);
    if(err != ESP_OK) {
      Serial.printf("âŒ æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥: 0x%x\n", err);
      return;
    }
    Serial.println("âœ… æ‘„åƒå¤´åˆå§‹åŒ–æˆåŠŸ");
    
    // æ‘„åƒå¤´é…ç½® - ä½¿ç”¨é‡å®šä¹‰çš„ç±»å‹
    camera_sensor_t *s = esp_camera_sensor_get();
    if (s != NULL) {
      s->set_vflip(s, 1);
      s->set_hmirror(s, 0);
      s->set_quality(s, 10);
      Serial.println("âœ… æ‘„åƒå¤´é…ç½®å®Œæˆ");
    }
    
    // å¯åŠ¨HTTPæœåŠ¡å™¨
    startCameraServer();
    delay(100);
    
    // åˆå§‹åŒ–WebSocket
    initWebSocket();
    delay(100);
  } else {
    Serial.println("âš ï¸ WiFiæœªè¿æ¥ï¼Œè·³è¿‡ç½‘ç»œæœåŠ¡åˆå§‹åŒ–");
  }
  
  
  initToFSensor();
  delay(100);
  
  
  // åˆå§‹åŒ–FastLEDç³»ç»Ÿ
  initLED();
  delay(100);
  
  // è®¾ç½®èˆµæœº
  servo_attach();
  delay(100);
  
  // èˆµæœºæµ‹è¯• - åŸºäºfly(2).inoçš„æµ‹è¯•
  Serial.println("ğŸ§ª å¼€å§‹åŸºäºfly(2).inoçš„èˆµæœºæµ‹è¯•...");
  for(int i = 0; i < 3; i++) {
    sla.write(min_angle);
    slb.write(min_angle);
    sra.write(min_angle);
    srb.write(min_angle);
    delay(200);  // åŸºäºfly(2).inoçš„æµ‹è¯•å»¶è¿Ÿ
    
    sla.write(max_angle);
    slb.write(max_angle);
    sra.write(max_angle);
    srb.write(max_angle);
    delay(200);  // åŸºäºfly(2).inoçš„æµ‹è¯•å»¶è¿Ÿ
  }
  
  // æµ‹è¯•fly(2).inoé£æ ¼çš„æ‰‘ç¿¼åŠ¨ä½œ
  Serial.println("ğŸ§ª æµ‹è¯•fly(2).inoé£æ ¼æ‰‘ç¿¼åŠ¨ä½œ...");
  for(float angle = 0; angle <= 180; angle += 10) {
    float angleL = 30 * sin(angle * PI / 180) + 90;
    float angleR = 30 * sin(angle * PI / 180 + PI) + 90;
    sla.write(angleL);
    sra.write(angleR);
    delay(50);  // åˆ©ç”¨è¶…å¿«å“åº”ç‰¹æ€§
  }
  
  // å›åˆ°ä¸­ä½
  sla.write(mid_angle);
  slb.write(mid_angle);
  sra.write(mid_angle);
  srb.write(mid_angle);
  Serial.println("âœ… èˆµæœºæµ‹è¯•å®Œæˆ");
  
  Serial.println("ğŸ‰ Skyris WiFi Stationç‰ˆæœ¬å¯åŠ¨å®Œæˆ!");
  Serial.printf("ğŸ“Š å¯ç”¨å†…å­˜: %d bytes\n", ESP.getFreeHeap());
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.printf("ğŸŒ Webç•Œé¢: http://%s\n", device_ip.c_str());
    Serial.printf("ğŸ”Œ WebSocket: ws://%s:81\n", device_ip.c_str());
    Serial.println("ğŸ“± ç°åœ¨å¯ä»¥é€šè¿‡æµè§ˆå™¨è®¿é—®æ§åˆ¶ç•Œé¢");
  } else {
    Serial.println("âš ï¸ WiFiæœªè¿æ¥ï¼Œè®¾å¤‡ä»¥ç¦»çº¿æ¨¡å¼è¿è¡Œ");
    Serial.println("ğŸ”§ ä¿®æ”¹ä»£ç ä¸­çš„WIFI_SSIDå’ŒWIFI_PASSåé‡å¯");
  }
  
  Serial.println("\nâš¡ åŠŸèƒ½çŠ¶æ€:");
  Serial.printf("- WiFiè¿æ¥: %s\n", WiFi.status() == WL_CONNECTED ? "å·²è¿æ¥" : "æœªè¿æ¥");
  Serial.printf("- VL53L1Xé¿éšœ: %s\n", tof_sensor_available ? "å·²è¿æ¥" : "æœªè¿æ¥");
  Serial.println("- LEDæ§åˆ¶: å·²å¯ç”¨");
  Serial.println("- èˆµæœºæ§åˆ¶: å·²å¯ç”¨");
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nâš¡ WiFi Stationæ¨¡å¼åŠŸèƒ½:");
    Serial.println("- è¿æ¥åˆ°ç°æœ‰WiFiç½‘ç»œ");
    Serial.println("- è‡ªåŠ¨è·å–IPåœ°å€");
    Serial.println("- æ”¯æŒè‡ªåŠ¨é‡è¿");
    Serial.println("- å®æ—¶ä¿¡å·å¼ºåº¦ç›‘æµ‹");
    Serial.println("- çƒ­æºè¿½è¸ª: 28Â°Cé˜ˆå€¼");
    Serial.println("- é£è¡Œæ¨¡å¼: æ‰‹åŠ¨/è¿½è¸ª/å·¡èˆª");
    Serial.println("- I2Cé…ç½®: SDA=GPIO5, SCL=GPIO6");
    Serial.println("\nğŸ“ å®šé«˜æ§åˆ¶åŠŸèƒ½:");
    Serial.printf("- ç›®æ ‡æ‚¬åœé«˜åº¦: %.1fç±³\n", targetAltitude);
    Serial.println("- å®‰å…¨ä¿æŠ¤: æœ€ä½1.5ç±³");
    Serial.println("- æ¨¡å¼å…¼å®¹: ä¸è¿½è¸ª/å·¡èˆªæ¨¡å¼å…±å­˜");
    Serial.println("- è‡ªåŠ¨æ ¡å‡†: é¦–æ¬¡å¯ç”¨æ—¶æ ¡å‡†èµ·é£ç‚¹");
    Serial.println("\nğŸš¨ å‰å‘é¿éšœåŠŸèƒ½:");
    Serial.printf("- VL53L1X ToFä¼ æ„Ÿå™¨: %s\n", tof_sensor_available ? "å·²è¿æ¥" : "æœªè¿æ¥");
    Serial.printf("- éšœç¢ç‰©é˜ˆå€¼: %.1fcm\n", obstacleThreshold);
    Serial.printf("- è­¦å‘Šé˜ˆå€¼: %.1fcm\n", warningThreshold);
    Serial.printf("- é¿éšœçŠ¶æ€: %s\n", obstacle_avoidance_active ? "å¯ç”¨" : "ç¦ç”¨");
    Serial.println("- é¿éšœç­–ç•¥: åœæ­¢->å·¦å³è½¬å‘->æ¢å¤å‰è¿›");
    Serial.println("- ä¼˜å…ˆçº§: æœ€é«˜ (è¦†ç›–æ‰€æœ‰å…¶ä»–æ§åˆ¶)");
    Serial.println("\nğŸ”§ åŸºäºfly(2).inoçš„èˆµæœºé…ç½®:");
    Serial.println("- è§’åº¦èŒƒå›´: 180Â° (800-2100us)");
    Serial.println("- å¼•è„šé…ç½®: sla=7, slb=8, sra=3, srb=4");
    Serial.println("- æ‰‘ç¿¼å¹…åº¦: 90åº¦ (æ›´å¤§å¹…åº¦)");
    Serial.println("- å»¶è¿Ÿæ—¶é—´: 5ms (åŸºäºfly(2).ino)");
    Serial.println("- åŒç¿¼4DOFç»“æ„ï¼šè½¬å‘+æ‰‘åŠ¨åˆ†ç¦»æ§åˆ¶");
    Serial.println("\nğŸ® WebSocketå‘½ä»¤:");
    Serial.println("- é£è¡Œ: IDLE, FWD, UP, DOWN, LEFT, RIGHT, BACK");
    Serial.println("- æ¨¡å¼: MANUAL, TRACK, CRUISE, ALTITUDE");
    Serial.println("- LEDæ§åˆ¶: LED_BREATH, LED_RAINBOW, LED_SOLID, LED_OFF");
    Serial.println("- LEDé¢œè‰²: LED_COLOR:R,G,B (ä¾‹å¦‚: LED_COLOR:255,0,0)");
    Serial.println("- é¿éšœæ§åˆ¶: TOF_ENABLE, TOF_DISABLE");
    Serial.println("- é¿éšœé˜ˆå€¼: TOF_THRESHOLD:è·ç¦»å˜ç±³ (ä¾‹å¦‚: TOF_THRESHOLD:40)");
    Serial.println("\nğŸŒˆ FastLEDåŠŸèƒ½:");
    Serial.printf("- LEDå¼•è„š: D2 (GPIO%d)\n", LED_PIN);
    Serial.printf("- LEDæ•°é‡: %dä¸ªWS2812B\n", NUM_LEDS);
    Serial.println("- å‘¼å¸ç¯: ç¬¦åˆäººä½“å‘¼å¸é¢‘ç‡ (12-20æ¬¡/åˆ†é’Ÿ)");
    Serial.println("- å½©è™¹æ¨¡å¼: åŠ¨æ€è‰²å½©å¾ªç¯");
    Serial.println("- å›ºå®šé¢œè‰²: å¯é€šè¿‡WebSocketè‡ªå®šä¹‰RGBé¢œè‰²");
  } else {
    Serial.println("\nâŒ ç½‘ç»œåŠŸèƒ½ç¦»çº¿:");
    Serial.println("- ä¿®æ”¹ä»£ç é¡¶éƒ¨çš„WIFI_SSIDå’ŒWIFI_PASS");
    Serial.println("- ç¡®ä¿ç›®æ ‡WiFiç½‘ç»œå¯ç”¨");
    Serial.println("- é‡æ–°ç¼–è¯‘å¹¶ä¸Šä¼ ä»£ç ");
    Serial.println("- ä¼ æ„Ÿå™¨å’ŒèˆµæœºåŠŸèƒ½æ­£å¸¸å·¥ä½œ");
  }
  
  //==================== æ–°å¢å¤šä»»åŠ¡æ³¨å†Œ ====================
  xTaskCreatePinnedToCore(ToFTask, "ToFTask", 4096, nullptr, 4, nullptr, 1);
  xTaskCreatePinnedToCore(ServoTask, "ServoTask", 4096, nullptr, 5, nullptr, 1);
  xTaskCreatePinnedToCore(LEDTask, "LEDTask", 4096, nullptr, 2, nullptr, 1);
  xTaskCreatePinnedToCore(FlightControlTask, "FlightControlTask", 4096, nullptr, 3, nullptr, 1);
  //==================== End ====================

   Serial.printf("ğŸ“Š å‰©ä½™å†…å­˜: %d bytes\n", ESP.getFreeHeap());
}

void loop(){ 
  webSocket.loop();

  // ====== æ–°å¢ï¼šå®šæœŸæ¨é€çŠ¶æ€åˆ°WebSocketå®¢æˆ·ç«¯ ======
  static unsigned long lastStatusPush = 0;
  if (millis() - lastStatusPush > 1000) { // æ¯1ç§’æ¨é€ä¸€æ¬¡
    String status = "{";
    status += "\"type\":\"status\",";
    status += "\"altitude\":" + String(currentAltitude, 2) + ",";
    status += "\"altitude_hold_enabled\":" + String(altitudeHoldEnabled ? "true" : "false") + ",";
    status += "\"avoidance_active\":" + String(obstacle_avoidance_active ? "true" : "false") + ",";
    status += "\"tof_distance\":" + String(tof_distance_cm, 1) + ",";
    status += "\"obstacle_detected\":" + String(obstacleDetected ? "true" : "false") + ",";
    status += "\"main_mode\":\"";
    status += (flight_mode == CRUISE_MODE ? "CRUISE" : "MANUAL");
    status += "\"";
    status += "}";
    webSocket.broadcastTXT(status);
    lastStatusPush = millis();
  }

  

  static unsigned long lastReport = 0;
  static unsigned long lastThermalTest = 0;
  
  // æ£€æŸ¥WiFiè¿æ¥çŠ¶æ€
  checkWiFiConnection();
  
  // æ¯60ç§’æŠ¥å‘Šä¸€æ¬¡çŠ¶æ€ (ä»30ç§’å¢åŠ åˆ°60ç§’)
  if(millis() - lastReport > 60000) {
    const char* mode_names[] = {"æ‰‹åŠ¨", "è¿½è¸ª", "å·¡èˆª", "å®šé«˜"};
    Serial.printf("âš¡ ç³»ç»Ÿè¿è¡Œä¸­ | WiFi: %s | å†…å­˜: %d bytes | æ–¹å‘: %s | æ¨¡å¼: %s\n", 
                  WiFi.status() == WL_CONNECTED ? "å·²è¿æ¥" : "æœªè¿æ¥",
                  ESP.getFreeHeap(), 
                  cmdMap[current_direction], 
                  mode_names[flight_mode]);
    
    if (WiFi.status() == WL_CONNECTED) {
      Serial.printf("ğŸ“ è®¾å¤‡IP: %s | ä¿¡å·å¼ºåº¦: %d dBm\n", device_ip.c_str(), WiFi.RSSI());
    }
    
    
    
    if (tof_sensor_available) {
      const char* obs_state_names[] = {"æ— éšœç¢", "è­¦å‘Š", "å·¦é¿éšœ", "å³é¿éšœ", "é˜»æŒ¡"};
      Serial.printf("ğŸš¨ é¿éšœçŠ¶æ€: è·ç¦»=%.1fcm, çŠ¶æ€=%s, æ¿€æ´»=%s\n", 
                    tof_distance_cm, 
                    obs_state_names[obstacle_state],
                    obstacle_avoidance_active ? "æ˜¯" : "å¦");
    }
    
    lastReport = millis();
  }
  
  // æ¯30ç§’å¼ºåˆ¶æµ‹è¯•çƒ­æˆåƒä¼ æ„Ÿå™¨ (ä»10ç§’å¢åŠ åˆ°30ç§’)
  if(millis() - lastThermalTest > 30000) {
    
    // æµ‹è¯•é¿éšœä¼ æ„Ÿå™¨
    if (tof_sensor_available && obstacle_avoidance_active) {
      Serial.println("\nğŸš¨ ===== å¼ºåˆ¶é¿éšœæµ‹è¯• =====");
      readToFData();
      
      Serial.printf("ğŸ“ ToFè·ç¦»: %.1fcm (çŠ¶æ€: %d)\n", tof_distance_cm, tof_range_status);
      Serial.printf("ğŸš¨ éšœç¢æ£€æµ‹: %s (é˜ˆå€¼: %.1fcm)\n", 
                    obstacleDetected ? "æ˜¯" : "å¦", obstacleThreshold);
      Serial.printf("âš ï¸ è­¦å‘ŠçŠ¶æ€: %s (é˜ˆå€¼: %.1fcm)\n", 
                    obstacleWarning ? "æ˜¯" : "å¦", warningThreshold);
      
      
      Serial.println("ğŸš¨ ========================\n");
    } else if (tof_sensor_available && !obstacle_avoidance_active) {
      Serial.println("ğŸš« ToFä¼ æ„Ÿå™¨å¯ç”¨ä½†é¿éšœå·²ç¦ç”¨");
    } else if (!tof_sensor_available) {
      Serial.println("âŒ ToFé¿éšœä¼ æ„Ÿå™¨ä¸å¯ç”¨");
    }
    
    lastThermalTest = millis();
  }
  
  // å¢åŠ ä¸»å¾ªç¯å»¶è¿Ÿï¼Œå‡å°‘CPUå ç”¨ (ä»100mså¢åŠ åˆ°200ms)
  delay(200);
}



//-------------------------------- FastLED Control Functions
void initLED() {
  Serial.println("ğŸŒˆ å¼€å§‹åˆå§‹åŒ–FastLEDç³»ç»Ÿ...");
  Serial.printf("ğŸ“ LEDå¼•è„š: D2 (GPIO%d)\n", LED_PIN);
  Serial.printf("ğŸ’¡ LEDæ•°é‡: %dä¸ªWS2812B\n", NUM_LEDS);
  
  // åˆå§‹åŒ–FastLED
  FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS);
  FastLED.setBrightness(255);
  FastLED.clear();
  FastLED.show();
  
  // LEDè¿æ¥æµ‹è¯• - å¢å¼ºç‰ˆæœ¬
  Serial.println("ğŸ§ª LEDè¿æ¥æµ‹è¯• (å¢å¼ºç‰ˆ)...");
  CRGB test_colors[] = {CRGB::Red, CRGB::Green, CRGB::Blue, CRGB::White, CRGB::Yellow, CRGB::Purple};
  String color_names[] = {"çº¢è‰²", "ç»¿è‰²", "è“è‰²", "ç™½è‰²", "é»„è‰²", "ç´«è‰²"};
  
  for (int c = 0; c < 6; c++) {
    Serial.printf("ğŸ”´ æµ‹è¯• %s (å…¨äº®åº¦)\n", color_names[c].c_str());
    fill_solid(leds, NUM_LEDS, test_colors[c]);
    FastLED.show();
    delay(500);
    
    // æµ‹è¯•äº®åº¦å˜åŒ–
    Serial.printf("ğŸ”… æµ‹è¯• %s (äº®åº¦å˜åŒ–)\n", color_names[c].c_str());
    for (int brightness = 255; brightness >= 50; brightness -= 50) {
      fill_solid(leds, NUM_LEDS, test_colors[c]);
      FastLED.setBrightness(brightness);
      FastLED.show();
      Serial.printf("   äº®åº¦: %d\n", brightness);
      delay(200);
    }
    FastLED.setBrightness(255);  // æ¢å¤å…¨äº®åº¦
  }
  
  // å‘¼å¸ç¯æ•ˆæœæµ‹è¯•
  Serial.println("ğŸ« å‘¼å¸ç¯æ•ˆæœæµ‹è¯•...");
  for (int cycle = 0; cycle < 3; cycle++) {
    for (int brightness = 50; brightness <= 255; brightness += 10) {
      fill_solid(leds, NUM_LEDS, CRGB::White);
      FastLED.setBrightness(brightness);
      FastLED.show();
      delay(50);
    }
    for (int brightness = 255; brightness >= 50; brightness -= 10) {
      fill_solid(leds, NUM_LEDS, CRGB::White);
      FastLED.setBrightness(brightness);
      FastLED.show();
      delay(50);
    }
  }
  
  // æ¸…ç©ºå¹¶å¯åŠ¨é»˜è®¤å‘¼å¸æ¨¡å¼
  FastLED.setBrightness(255);  // ç¡®ä¿äº®åº¦è®¾ç½®æ­£ç¡®
  // ä¸è¦æ¸…ç©ºLEDï¼Œä¿æŒç™½è‰²ä»¥ä¾¿å‘¼å¸ç¯æ•ˆæœæ­£å¸¸
  fill_solid(leds, NUM_LEDS, CRGB::White);  // è®¾ç½®ä¸ºç™½è‰²
  FastLED.show();
  delay(200);
  
  Serial.println("âœ… FastLEDç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
  Serial.println("ğŸ« é»˜è®¤æ¨¡å¼: ç™½è‰²å‘¼å¸ç¯ (å¢å¼ºå¯¹æ¯”åº¦)");
}

void updateLED() {
  static unsigned long last_debug = 0;
  bool debug_output = (millis() - last_debug > 10000);  // å‡å°‘åˆ°æ¯10ç§’è¾“å‡ºä¸€æ¬¡è°ƒè¯•ä¿¡æ¯
  
  if (debug_output) {
    Serial.printf("ğŸŒˆ LEDæ›´æ–°: å¯ç”¨=%s, æ¨¡å¼=%d\n", led_enabled ? "æ˜¯" : "å¦", current_led_mode);
    last_debug = millis();
  }
  
  if (!led_enabled) {
    FastLED.clear();
    FastLED.show();
    return;
  }
  
  switch (current_led_mode) {
    case LED_BREATH:
      updateBreathEffect();
      if (debug_output) {
        Serial.printf("ğŸ« å‘¼å¸ç¯æ¨¡å¼: é¢œè‰²=(%d,%d,%d), å…¨å±€äº®åº¦=%d\n", 
                      leds[0].r, leds[0].g, leds[0].b, FastLED.getBrightness());
      }
      break;
    case LED_RAINBOW:
      updateRainbowEffect();
      if (debug_output) {
        Serial.printf("ğŸŒˆ å½©è™¹æ¨¡å¼: è‰²ç›¸=%d, LED0=(%d,%d,%d)\n", 
                      rainbow_hue, leds[0].r, leds[0].g, leds[0].b);
      }
      break;
    case LED_SOLID:
      updateSolidColor();
      if (debug_output) {
        Serial.printf("ğŸ’¡ å›ºå®šé¢œè‰²: (%d,%d,%d)\n", leds[0].r, leds[0].g, leds[0].b);
      }
      break;
    case LED_OFF:
      FastLED.clear();
      FastLED.setBrightness(0);  // è®¾ç½®äº®åº¦ä¸º0
      if (debug_output) {
        Serial.println("âš« LEDå…³é—­æ¨¡å¼");
      }
      break;
  }
  
  // åªåœ¨éå‘¼å¸ç¯æ¨¡å¼ä¸‹è°ƒç”¨FastLED.show()ï¼Œå› ä¸ºupdateBreathEffect()å†…éƒ¨å·²ç»å¤„ç†äº†
  if (current_led_mode != LED_BREATH) {
    FastLED.show();
  }
  
  if (debug_output) {
    Serial.printf("âœ… FastLEDå¤„ç†å®Œæˆ (æ¨¡å¼=%d)\n", current_led_mode);
  }
}

void updateBreathEffect() {
  static unsigned long last_debug = 0;
  bool debug_output = (millis() - last_debug > 15000);  // å‡å°‘åˆ°æ¯15ç§’è¾“å‡ºä¸€æ¬¡è°ƒè¯•ä¿¡æ¯
  
  // æ ¹æ®WebSocketè¿æ¥çŠ¶æ€é€‰æ‹©å‘¼å¸é€Ÿåº¦
  float current_speed = websocket_connected ? breath_speed_connected : breath_speed;
  
  // æ›´æ–°å‘¼å¸ç›¸ä½ - ç¬¦åˆäººä½“å‘¼å¸é¢‘ç‡ (çº¦12-20æ¬¡/åˆ†é’Ÿ)
  breath_phase += current_speed;
  if (breath_phase > TWO_PI) {
    breath_phase = 0.0;
  }
  
  // ä½¿ç”¨æ›´æ˜æ˜¾çš„äº®åº¦å˜åŒ–ç®—æ³•
  float sine_value = sin(breath_phase);
  // å°†æ­£å¼¦å€¼ä»[-1,1]æ˜ å°„åˆ°[0,1]ï¼Œç„¶ååº”ç”¨å¹³æ–¹å‡½æ•°å¢å¼ºå¯¹æ¯”åº¦
  float normalized = (sine_value + 1.0) / 2.0;
  float enhanced = normalized * normalized;  // å¹³æ–¹å‡½æ•°å¢å¼ºå¯¹æ¯”åº¦
  
  // ç®€åŒ–é¢œè‰²äº®åº¦æ£€æŸ¥ - åªåœ¨è°ƒè¯•æ—¶è®¡ç®—
  int adjusted_min_brightness = min_brightness;
  int adjusted_max_brightness = max_brightness;
  
  // å¦‚æœæ˜¯æ·±è‰²ï¼ˆå¦‚çº¯è“è‰²ï¼‰ï¼Œå¢åŠ äº®åº¦èŒƒå›´
  if (debug_output) {
    int color_brightness = (breath_color.r + breath_color.g + breath_color.b) / 3;
    if (color_brightness < 128) {
      adjusted_min_brightness = 80;   // æé«˜æœ€å°äº®åº¦
      adjusted_max_brightness = 255;  // ä¿æŒæœ€å¤§äº®åº¦
      Serial.printf("ğŸ”µ æ£€æµ‹åˆ°æ·±è‰²ï¼Œè°ƒæ•´äº®åº¦èŒƒå›´: %d-%d\n", adjusted_min_brightness, adjusted_max_brightness);
    }
  }
  
  int current_brightness = adjusted_min_brightness + (int)((adjusted_max_brightness - adjusted_min_brightness) * enhanced);
  
  // ç¡®ä¿äº®åº¦åœ¨æœ‰æ•ˆèŒƒå›´å†…
  current_brightness = constrain(current_brightness, adjusted_min_brightness, adjusted_max_brightness);
  
  if (debug_output) {
    Serial.printf("ğŸ« å‘¼å¸ç¯å¢å¼º: ç›¸ä½=%.2f, æ­£å¼¦å€¼=%.2f, æ ‡å‡†åŒ–=%.2f, å¢å¼º=%.2f, äº®åº¦=%d\n", 
                  breath_phase, sine_value, normalized, enhanced, current_brightness);
    Serial.printf("ğŸ¨ åŸºç¡€é¢œè‰²: R=%d, G=%d, B=%d (èŒƒå›´: %d-%d)\n", 
                  breath_color.r, breath_color.g, breath_color.b, adjusted_min_brightness, adjusted_max_brightness);
    last_debug = millis();
  }
  
  // ä½¿ç”¨FastLEDå…¨å±€äº®åº¦æ§åˆ¶ï¼Œè€Œä¸æ˜¯ç›´æ¥ä¿®æ”¹RGBå€¼
  // å…ˆè®¾ç½®åŸºç¡€é¢œè‰²åˆ°æ‰€æœ‰LED
  fill_solid(leds, NUM_LEDS, breath_color);
  
  // ç„¶åä½¿ç”¨FastLEDçš„å…¨å±€äº®åº¦æ§åˆ¶
  FastLED.setBrightness(current_brightness);
  
  // ç«‹å³åº”ç”¨äº®åº¦è®¾ç½®
  FastLED.show();
  
  if (debug_output) {
    Serial.printf("ğŸ” è®¾ç½®å…¨å±€äº®åº¦: %d, LED[0]åŸºç¡€é¢œè‰²: R=%d, G=%d, B=%d\n", 
                  current_brightness, leds[0].r, leds[0].g, leds[0].b);
  }
}

void updateRainbowEffect() {
  rainbow_hue += 2;  // å½©è™¹è‰²ç›¸é€’å¢
  
  // ç¡®ä¿å…¨å±€äº®åº¦è®¾ç½®ä¸ºæœ€å¤§
  FastLED.setBrightness(255);
  
  for (int i = 0; i < NUM_LEDS; i++) {
    // æ¯ä¸ªLEDæœ‰ä¸åŒçš„è‰²ç›¸åç§»ï¼Œåˆ›é€ å½©è™¹æ•ˆæœ
    leds[i] = CHSV(rainbow_hue + (i * 128), 255, 255);
  }
}

void updateSolidColor() {
  // å›ºå®šé¢œè‰²æ¨¡å¼
  fill_solid(leds, NUM_LEDS, breath_color);
  
  // ç¡®ä¿å…¨å±€äº®åº¦è®¾ç½®ä¸ºæœ€å¤§
  FastLED.setBrightness(255);
}

void setLEDMode(LedMode mode) {
  current_led_mode = mode;
  String mode_names[] = {"å‘¼å¸ç¯", "å½©è™¹", "å›ºå®šé¢œè‰²", "å…³é—­"};
  
  Serial.printf("ğŸ¨ LEDæ¨¡å¼åˆ‡æ¢: %s\n", mode_names[mode].c_str());
}

void setLEDColor(uint8_t r, uint8_t g, uint8_t b) {
  breath_color = CRGB(r, g, b);
  Serial.printf("ğŸ¨ LEDé¢œè‰²è®¾ç½®: R=%d, G=%d, B=%d\n", r, g, b);
}

void setLEDColor(CRGB color) {
  breath_color = color;
  Serial.printf("ğŸ¨ LEDé¢œè‰²è®¾ç½®: #%02X%02X%02X\n", color.r, color.g, color.b);
}

void setLEDEnabled(bool enabled) {
  led_enabled = enabled;
  if (!enabled) {
    FastLED.clear();
    FastLED.show();
  }
  Serial.printf("ğŸ’¡ LED %s\n", enabled ? "å¼€å¯" : "å…³é—­");
}

// å¤„ç†LEDé¢œè‰²å‘½ä»¤ (æ ¼å¼: LED_COLOR:R,G,B)
void processLEDColorCommand(String command) {
  int colon_pos = command.indexOf(':');
  if (colon_pos == -1) {
    Serial.println("âŒ LEDé¢œè‰²å‘½ä»¤æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º LED_COLOR:R,G,B");
    return;
  }
  
  String color_data = command.substring(colon_pos + 1);
  int comma1 = color_data.indexOf(',');
  int comma2 = color_data.lastIndexOf(',');
  
  if (comma1 == -1 || comma2 == -1 || comma1 == comma2) {
    Serial.println("âŒ LEDé¢œè‰²æ•°æ®æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º R,G,B");
    return;
  }
  
  int r = color_data.substring(0, comma1).toInt();
  int g = color_data.substring(comma1 + 1, comma2).toInt();
  int b = color_data.substring(comma2 + 1).toInt();
  
  // éªŒè¯é¢œè‰²å€¼èŒƒå›´
  if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
    Serial.println("âŒ LEDé¢œè‰²å€¼è¶…å‡ºèŒƒå›´ (0-255)");
    return;
  }
  
  setLEDColor(r, g, b);
  current_led_mode = LED_SOLID;  // è®¾ç½®é¢œè‰²ååˆ‡æ¢åˆ°å›ºå®šé¢œè‰²æ¨¡å¼
  Serial.printf("âœ… LEDé¢œè‰²å·²è®¾ç½®å¹¶åˆ‡æ¢åˆ°å›ºå®šé¢œè‰²æ¨¡å¼\n");
}

//-------------------------------- HTTP Server Functions
static esp_err_t index_handler(httpd_req_t *req) {
  const char* html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skyris WebSocket Control</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f0f0f0; }
        .container { max-width: 1200px; margin: 0 auto; }
        .panel { background: white; border-radius: 10px; padding: 20px; margin: 10px 0; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-width: 300px; margin: 0 auto; }
        .btn { padding: 15px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; transition: all 0.3s; }
        .btn:hover { transform: scale(1.05); }
        .flight-btn { background: #4CAF50; color: white; }
        .flight-btn:hover { background: #45a049; }
        .led-btn { background: #2196F3; color: white; margin: 5px; }
        .led-btn:hover { background: #1976D2; }
        .status { padding: 10px; border-radius: 5px; margin: 10px 0; }
        .connected { background: #d4edda; color: #155724; }
        .disconnected { background: #f8d7da; color: #721c24; }
        .color-picker { margin: 10px; }
        
        /* Toggle Switch Styles */
        .switch-container { display: flex; align-items: center; gap: 10px; cursor: pointer; }
        .switch-container input[type="checkbox"] { opacity: 0; width: 0; height: 0; }
        .slider { position: relative; display: inline-block; width: 60px; height: 34px; background-color: #ccc; border-radius: 34px; transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; border-radius: 50%; transition: .4s; }
        .switch-container input:checked + .slider { background-color: #4CAF50; }
        .switch-container input:checked + .slider:before { transform: translateX(26px); }
        .switch-label { font-weight: bold; color: #333; }
        .preset-colors { display: flex; gap: 10px; margin: 10px 0; }
        .color-preset {
          width: 36px; height: 36px; border-radius: 50%; cursor: pointer; border: 2px solid #ccc;
          font-weight: bold; font-size: 14px; outline: none;
        }
        .color-preset:active { border: 2px solid #333; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš Skyris WebSocket Control</h1>
        
        <div class="panel">
            <h2>ğŸ”Œ Connection Status</h2>
            <div id="status" class="status disconnected">Disconnected</div>
        </div>
        
        <div class="panel">
            <h2>ğŸ® Flight Control & Data</h2>
            
            <!-- Flight Control Grid -->
            <div style="display: flex; gap: 20px; align-items: flex-start;">
                <!-- Control Buttons -->
                <div style="flex: 1;">
                    <h3 style="margin: 0 0 10px 0;">é¥æ§å™¨</h3>
                    <div class="grid">
                        <div></div>
                        <button class="btn flight-btn" onclick="sendCommand('UP')">â¬†ï¸ UP</button>
                        <div></div>
                        <button class="btn flight-btn" onclick="sendCommand('LEFT')">â¬…ï¸ LEFT</button>
                        <button class="btn flight-btn" onclick="sendCommand('IDLE')" style="background: #f44336;">ğŸ›‘ STOP</button>
                        <button class="btn flight-btn" onclick="sendCommand('RIGHT')">â¡ï¸ RIGHT</button>
                        <button class="btn flight-btn" onclick="sendCommand('BACK')">â¬‡ï¸ BACK</button>
                        <button class="btn flight-btn" onclick="sendCommand('DOWN')">â¬‡ï¸ DOWN</button>
                        <button class="btn flight-btn" onclick="sendCommand('FWD')">â¬†ï¸ FWD</button>
                        <button class="btn flight-btn" onclick="sendCommand('LWAVE')" style="background: #9C27B0; font-size: 12px; padding: 8px 12px;">ã€°ï¸ LEFT WAVE</button>
                        <button class="btn flight-btn" onclick="sendCommand('RWAVE')" style="background: #FF5722; font-size: 12px; padding: 8px 12px;">ã€°ï¸ RIGHT WAVE</button>
                    </div>
                </div>
                
                <!-- Flight Modes -->
                <div style="flex: 1;">
                    <h3 style="margin: 0 0 10px 0;">é£è¡Œæ¨¡å¼</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                        <button class="btn led-btn" onclick="sendCommand('MANUAL')" style="background: #FF9800; font-size: 12px;">ğŸ® Manual</button>
                        <!-- <button class="btn led-btn" onclick="sendCommand('TRACK')" style="background: #E91E63; font-size: 12px;">ğŸ”¥ Track</button> åˆ é™¤ -->
                        <button class="btn led-btn" onclick="sendCommand('CRUISE')" style="background: #9C27B0; font-size: 12px;">ğŸ² Cruise</button>
                        <button class="btn led-btn" onclick="sendCommand('ALTITUDE')" style="background: #4CAF50; font-size: 12px;">ğŸ“ Altitude</button>
                    </div>
                    <div id="currentMode" style="margin-top: 8px; font-weight: bold; font-size: 14px;">Current Mode: Manual</div>
                </div>
                
                <!-- Flight Data -->
                <div style="flex: 1;">
                    <h3 style="margin: 0 0 10px 0;">é£è¡Œæ•°æ®</h3>
                    <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; font-size: 14px; margin-bottom: 10px;">
                        ğŸ“ <strong>é«˜åº¦:</strong> <span id="altitudeDisplay">-- m</span><br>
                        ğŸ¯ <strong>å®šé«˜çŠ¶æ€:</strong> <span id="altitudeStatus">--</span><br>
                        ğŸ›¡ï¸ <strong>é¿éšœçŠ¶æ€:</strong> <span id="avoidanceStatus">--</span><br>
                        ğŸ“¡ <strong>ToFè·ç¦»:</strong> <span id="distanceDisplay">-- cm</span>
                    </div>
                </div>
            </div>
            
            <!-- Quick Info Banner -->
            <div style="margin-top: 15px; padding: 8px; background: #e8f5e8; border-radius: 5px; font-size: 12px; text-align: center;">
                ğŸ’¡ <strong>æç¤º:</strong> å®šé«˜æ¨¡å¼è‡ªåŠ¨ä¿æŒ1.5ç±³æ‚¬åœ | é¿éšœæ¨¡å¼50cmå†…è‡ªåŠ¨åœæ­¢ | æ‰€æœ‰æ¨¡å¼å¯ç»„åˆä½¿ç”¨
            </div>
        </div>
        
        <div class="panel">
            <h2>ğŸŒˆ LED Control</h2>
            <div>
                <button class="btn led-btn" onclick="sendCommand('LED_BREATH')">ğŸ« Breathing</button>
                <button class="btn led-btn" onclick="sendCommand('LED_RAINBOW')">ğŸŒˆ Rainbow</button>
                <button class="btn led-btn" onclick="sendCommand('LED_SOLID')">ğŸ’¡ Solid</button>
                <button class="btn led-btn" onclick="sendCommand('LED_OFF')">âš« Off</button>
            </div>
            <div style="margin: 10px 0; padding: 10px; background: #e8f5e8; border-radius: 5px; font-size: 14px;">
                ğŸ’¡ <strong>æç¤º:</strong> å‘¼å¸ç¯æ¨¡å¼ä½¿ç”¨å½“å‰é€‰æ‹©çš„é¢œè‰²ï¼Œå»ºè®®ä½¿ç”¨è¾ƒäº®çš„é¢œè‰²ä»¥è·å¾—æœ€ä½³æ•ˆæœ
            </div>
            <div class="color-picker">
                <label>Custom Color: </label>
                <input type="color" id="colorPicker" value="#ffffff" onchange="updateColor()">
            </div>
            <div style="margin: 10px 0; font-weight: bold;">é¢œè‰²é€‰æ‹©ï¼š</div>
            <div class="preset-colors">
              <button class="color-preset" style="background: white; border: 1px solid #ccc;" onclick="setPresetColor(255,255,255)"></button>
              <button class="color-preset" style="background: red;" onclick="setPresetColor(255,0,0)"></button>
              <button class="color-preset" style="background: orange;" onclick="setPresetColor(255,128,0)"></button>
              <button class="color-preset" style="background: yellow; border: 1px solid #ccc;" onclick="setPresetColor(255,255,0)"></button>
              <button class="color-preset" style="background: green;" onclick="setPresetColor(0,255,0)"></button>
              <button class="color-preset" style="background: cyan;" onclick="setPresetColor(0,255,255)"></button>
              <button class="color-preset" style="background: blue;" onclick="setPresetColor(0,0,255)"></button>
              <button class="color-preset" style="background: purple;" onclick="setPresetColor(128,0,255)"></button>
            </div>
        </div>
        
        <div class="panel">
            <h2>ğŸ“¹ Camera Stream</h2>
            <img src="/stream" style="max-width: 100%; border-radius: 10px;">
        </div>
        
        <div class="panel">
            <h2>ğŸš Obstacle Avoidance</h2>
            <div style="margin-bottom: 15px;">
                <label class="switch-container">
                    <input type="checkbox" id="obstacleToggle" onchange="toggleObstacleAvoidance()">
                    <span class="slider"></span>
                    <span class="switch-label">é¿éšœæ¨¡å¼</span>
                </label>
            </div>
            <div id="obstacleStatus" style="margin: 10px 0; padding: 10px; background: #f5f5f5; border-radius: 5px; font-size: 14px;">
                ğŸš« é¿éšœå·²å…³é—­
            </div>
            <div id="obstacleDetails" style="margin: 10px 0; padding: 10px; background: #e8f5e8; border-radius: 5px; font-size: 12px; display: none;">
                ğŸ“Š <strong>ä¼ æ„Ÿå™¨çŠ¶æ€:</strong><br>
                â€¢ è·ç¦»: <span id="obstacleDistance">-- cm</span><br>
                â€¢ é˜ˆå€¼: éšœç¢ç‰©50cm / è­¦å‘Š60cm<br>
                â€¢ ä¼ æ„Ÿå™¨: <span id="sensorStatus">æ£€æµ‹ä¸­...</span>
            </div>
            <div style="margin: 10px 0; padding: 10px; background: #fff3cd; border-radius: 5px; font-size: 12px;">
                âš ï¸ <strong>æ³¨æ„:</strong> é¿éšœæ¨¡å¼ä¼šåœ¨æ£€æµ‹åˆ°éšœç¢ç‰©æ—¶è‡ªåŠ¨è¦†ç›–é£è¡Œå‘½ä»¤ï¼Œä¼˜å…ˆçº§æœ€é«˜
            </div>
        </div>
    </div>

    <script>
        let ws;
        let wsConnected = false;
        
      function updateFlightData(data) {
    if (data.altitude !== undefined) {
        var altitudeSpan = document.getElementById('altitudeDisplay');
        if (altitudeSpan) {
            altitudeSpan.textContent = data.altitude.toFixed(2) + ' m';
            altitudeSpan.style.color = '#28a745';
        }
    }
      if (data.altitude_hold_enabled !== undefined) {
          var statusSpan = document.getElementById('altitudeStatus');
          if (statusSpan) {
              statusSpan.textContent = data.altitude_hold_enabled ? 'âœ… å®šé«˜å·²å¯ç”¨' : 'âš« æ‰‹åŠ¨æ¨¡å¼';
              statusSpan.style.color = '#28a745';
          }
      }
    if (data.avoidance_active !== undefined) {
        var avoidanceSpan = document.getElementById('avoidanceStatus');
        if (avoidanceSpan) {
            avoidanceSpan.textContent = data.avoidance_active ? 'ğŸ›¡ï¸ å·²å¯ç”¨' : 'âš« å·²å…³é—­';
            avoidanceSpan.style.color = '#28a745';
        }
    }
    if (data.tof_distance !== undefined) {
        var distanceSpan = document.getElementById('distanceDisplay');
        if (distanceSpan) {
            distanceSpan.textContent = data.tof_distance.toFixed(1) + ' cm';
            distanceSpan.style.color = '#28a745';
        }
    }
}
function updateCurrentMode(data) {
    // ä¸»æ¨¡å¼æŒ‰é’®
    const manualBtn = document.querySelector('button[onclick*="MANUAL"]');
    const cruiseBtn = document.querySelector('button[onclick*="CRUISE"]');
    // å‰¯æ¨¡å¼æŒ‰é’®
    const altitudeBtn = document.querySelector('button[onclick*="ALTITUDE"]');
    // é«˜äº®ä¸»æ¨¡å¼
    if (data.main_mode === 'MANUAL') {
        manualBtn && manualBtn.classList.add('active');
        cruiseBtn && cruiseBtn.classList.remove('active');
    } else if (data.main_mode === 'CRUISE') {
        cruiseBtn && cruiseBtn.classList.add('active');
        manualBtn && manualBtn.classList.remove('active');
    }
    // é«˜äº®å‰¯æ¨¡å¼
    if (altitudeBtn) {
        if (data.altitude_hold_enabled) altitudeBtn.classList.add('active');
        else altitudeBtn.classList.remove('active');
    }
    // é¿éšœå‰¯æ¨¡å¼ï¼ˆç”¨checkboxæˆ–æŒ‰é’®ï¼ŒæŒ‰ä½ çš„UIç»“æ„å¤„ç†ï¼‰
    const obstacleToggle = document.getElementById('obstacleToggle');
    if (obstacleToggle) {
        obstacleToggle.checked = !!data.avoidance_active;
    }
    // æ¨¡å¼æ–‡æœ¬æ˜¾ç¤º
    let modeText = (data.main_mode === 'CRUISE' ? 'å·¡èˆª' : 'æ‰‹åŠ¨');
    let subModes = [];
    if (data.altitude_hold_enabled) subModes.push('å®šé«˜');
    if (data.avoidance_active) subModes.push('é¿éšœ');
    if (subModes.length > 0) modeText += ' + ' + subModes.join(' + ');
    const modeDiv = document.getElementById('currentMode');
    if (modeDiv) modeDiv.textContent = 'å½“å‰æ¨¡å¼: ' + modeText;

        // é¿éšœè¯¦ç»†çŠ¶æ€
    if (data.avoidance_active !== undefined) {
        var details = document.getElementById('obstacleDetails');
        if (details) details.style.display = data.avoidance_active ? 'block' : 'none';
        var statusDiv = document.getElementById('obstacleStatus');
        if (statusDiv) {
            statusDiv.innerHTML = data.avoidance_active ? 'ğŸ›¡ï¸ é¿éšœæ¨¡å¼å·²å¯ç”¨' : 'ğŸš« é¿éšœå·²å…³é—­';
            statusDiv.style.background = data.avoidance_active ? '#d4edda' : '#f5f5f5';
            statusDiv.style.color = data.avoidance_active ? '#155724' : '#666';
        }
    }
    if (data.tof_distance !== undefined) {
        var distSpan = document.getElementById('obstacleDistance');
        if (distSpan) distSpan.textContent = data.tof_distance.toFixed(1) + ' cm';
    }
    if (data.obstacle_detected !== undefined) {
        var sensorSpan = document.getElementById('sensorStatus');
        if (sensorSpan) sensorSpan.textContent = data.obstacle_detected ? 'âš ï¸ æœ‰éšœç¢ç‰©' : 'âœ… æ­£å¸¸';
        if (sensorSpan) sensorSpan.style.color = data.obstacle_detected ? '#e53935' : '#28a745';
    }
}
        


        function connectWebSocket() {
            ws = new WebSocket('ws://' + window.location.hostname + ':81');
            ws.onopen = function() {
                wsConnected = true;
                document.getElementById('status').className = 'status connected';
                document.getElementById('status').textContent = 'Connected to WebSocket';
                console.log('WebSocket connected');
            };
            ws.onclose = function() {
                wsConnected = false;
                document.getElementById('status').className = 'status disconnected';
                document.getElementById('status').textContent = 'Disconnected - Reconnecting...';
                console.log('WebSocket disconnected');
                setTimeout(connectWebSocket, 3000);
            };
            ws.onmessage = function(event) {
    try {
        const data = JSON.parse(event.data);
        if (data.type === 'status') {
            updateFlightData(data);
            updateCurrentMode(data);
        } else if (data.type === 'mode') {
            updateCurrentMode(data);
        } else if (data.type === 'response') {
            // ...åŸæœ‰å¤„ç†...
        }
    } catch (e) {
        console.log('Non-JSON message:', event.data);
    }
};
            ws.onerror = function(error) {
                console.log('WebSocket error:', error);
            };
        }
        
        function sendCommand(command) {
            if (wsConnected && ws.readyState === WebSocket.OPEN) {
                ws.send(command);
                console.log('Sent command:', command);
            } else {
                console.log('WebSocket not connected');
            }
        }
        
        
        function updateColor() {
            const color = document.getElementById('colorPicker').value;
            const r = parseInt(color.substr(1, 2), 16);
            const g = parseInt(color.substr(3, 2), 16);
            const b = parseInt(color.substr(5, 2), 16);
            sendCommand(`LED_COLOR:${r},${g},${b}`);
        }
        
        function setPresetColor(r, g, b) {
            sendCommand(`LED_COLOR:${r},${g},${b}`);
            const hex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            document.getElementById('colorPicker').value = hex;
        }
        
        // Connect on page load
        connectWebSocket();
        
        function toggleObstacleAvoidance() {
            const toggle = document.getElementById('obstacleToggle');
            const status = document.getElementById('obstacleStatus');
            const details = document.getElementById('obstacleDetails');
            
            if (toggle.checked) {
                sendCommand('TOF_ENABLE');
                status.innerHTML = 'ğŸ›¡ï¸ é¿éšœæ¨¡å¼å·²å¯ç”¨';
                status.style.background = '#d4edda';
                status.style.color = '#155724';
                details.style.display = 'block';
                console.log('å¯ç”¨é¿éšœæ¨¡å¼');
            } else {
                sendCommand('TOF_DISABLE');
                status.innerHTML = 'ğŸš« é¿éšœå·²å…³é—­';
                status.style.background = '#f5f5f5';
                status.style.color = '#666';
                details.style.display = 'none';
                console.log('å…³é—­é¿éšœæ¨¡å¼');
            }
        }
    </script>
</body>
</html>
)rawliteral";
  
  httpd_resp_set_type(req, "text/html");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  return httpd_resp_send(req, html, strlen(html));
}



static esp_err_t mode_handler(httpd_req_t *req) {
  size_t buf_len = httpd_req_get_url_query_len(req) + 1;
  if (buf_len > 1) {
    char* buf = (char*)malloc(buf_len);
    if (httpd_req_get_url_query_str(req, buf, buf_len) == ESP_OK) {
      char param[32];
      if (httpd_query_key_value(buf, "mode", param, sizeof(param)) == ESP_OK) {
        String mode = String(param);
        mode.toUpperCase();
        processCommand(mode);
      }
    }
    free(buf);
  }
  
  httpd_resp_set_type(req, "text/plain");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  return httpd_resp_send(req, "OK", 2);
}

static esp_err_t capture_handler(httpd_req_t *req) {
  camera_fb_t *fb = esp_camera_fb_get();
  if (!fb) {
    httpd_resp_send_500(req);
    return ESP_FAIL;
  }
  
  httpd_resp_set_type(req, "image/jpeg");
  httpd_resp_set_hdr(req, "Content-Disposition", "inline; filename=capture.jpg");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  
  esp_err_t res = httpd_resp_send(req, (const char *)fb->buf, fb->len);
  esp_camera_fb_return(fb);
  
  return res;
}

#define PART_BOUNDARY "123456789000000000000987654321"
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" PART_BOUNDARY;
static const char* _STREAM_BOUNDARY = "\r\n--" PART_BOUNDARY "\r\n";
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

static esp_err_t stream_handler(httpd_req_t *req) {
  Serial.println("ğŸ“¹ æ”¶åˆ°è§†é¢‘æµè¯·æ±‚");
  
  camera_fb_t *fb = NULL;
  esp_err_t res = ESP_OK;
  char part_buf[128];
  
  res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if (res != ESP_OK) {
    Serial.printf("âŒ è®¾ç½®å“åº”ç±»å‹å¤±è´¥: %d\n", res);
    return res;
  }
  
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  httpd_resp_set_hdr(req, "Cache-Control", "no-cache, no-store, must-revalidate");
  httpd_resp_set_hdr(req, "Pragma", "no-cache");
  httpd_resp_set_hdr(req, "Expires", "0");
  Serial.println("âœ… è§†é¢‘æµå“åº”å¤´è®¾ç½®å®Œæˆ");
  
  int frame_count = 0;
  unsigned long last_frame_time = millis();
  
  while (true) {
    unsigned long frame_start = millis();
    
    fb = esp_camera_fb_get();
    if (!fb) {
      Serial.printf("âŒ è·å–æ‘„åƒå¤´å¸§å¤±è´¥ (å¸§#%d)\n", frame_count);
      res = ESP_FAIL;
      break;
    }
    
    // å‡å°‘è°ƒè¯•è¾“å‡ºé¢‘ç‡ï¼Œé¿å…å½±å“æ€§èƒ½
    if (frame_count % 100 == 0) {  // æ¯100å¸§è¾“å‡ºä¸€æ¬¡è°ƒè¯•ä¿¡æ¯
      unsigned long fps = 1000 / (millis() - last_frame_time + 1);
      Serial.printf("ğŸ“¹ è§†é¢‘æµæ­£å¸¸ - å¸§#%d, å¤§å°=%d bytes, FPSâ‰ˆ%lu\n", frame_count, fb->len, fps);
      last_frame_time = millis();
    }
    
    // å‘é€è¾¹ç•Œ
    if (res == ESP_OK) {
      res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    }
    
    // å‘é€å¤´éƒ¨
    if (res == ESP_OK) {
      size_t hlen = snprintf(part_buf, 128, _STREAM_PART, fb->len);
      res = httpd_resp_send_chunk(req, part_buf, hlen);
    }
    
    // å‘é€å›¾åƒæ•°æ®
    if (res == ESP_OK) {
      res = httpd_resp_send_chunk(req, (const char *)fb->buf, fb->len);
    }
    
    esp_camera_fb_return(fb);
    
    if (res != ESP_OK) {
      Serial.printf("âŒ è§†é¢‘æµå‘é€å¤±è´¥: %d (å¸§#%d)\n", res, frame_count);
      break;
    }
    
    frame_count++;
    
    // åŠ¨æ€å¸§ç‡æ§åˆ¶ - æ ¹æ®å¤„ç†æ—¶é—´è°ƒæ•´å»¶è¿Ÿ
    unsigned long frame_time = millis() - frame_start;
    if (frame_time < 66) {  // ç›®æ ‡15FPS (66ms per frame)
      vTaskDelay(pdMS_TO_TICKS(66 - frame_time));
    } else {
      vTaskDelay(pdMS_TO_TICKS(10));  // æœ€å°å»¶è¿Ÿï¼Œé¿å…é˜»å¡å…¶ä»–ä»»åŠ¡
    }
  }
  
  Serial.printf("ğŸ“¹ è§†é¢‘æµç»“æŸ - æ€»å¸§æ•°: %d\n", frame_count);
  return res;
}

void startCameraServer() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 80;
  config.max_uri_handlers = 10;
  config.task_priority = 5;  // æé«˜HTTPä¼˜å…ˆçº§ (ä»4æé«˜åˆ°5)
  config.stack_size = 12288;  // å¢åŠ æ ˆå¤§å° (ä»8192å¢åŠ åˆ°12288)
  config.core_id = 0;
  config.max_open_sockets = 5;  // å‡å°‘æœ€å¤§è¿æ¥æ•°ï¼Œæé«˜ç¨³å®šæ€§
  config.lru_purge_enable = true;  // å¯ç”¨LRUæ¸…ç†
  config.recv_wait_timeout = 10;   // å‡å°‘æ¥æ”¶è¶…æ—¶
  config.send_wait_timeout = 10;   // å‡å°‘å‘é€è¶…æ—¶
  
  Serial.println("ğŸ”§ å¼€å§‹å¯åŠ¨HTTPæœåŠ¡å™¨...");
  
  if (httpd_start(&camera_httpd, &config) == ESP_OK) {
    Serial.println("âœ… HTTPæœåŠ¡å™¨å¯åŠ¨æˆåŠŸï¼Œå¼€å§‹æ³¨å†Œè·¯ç”±...");
    
    httpd_uri_t index_uri = {.uri = "/", .method = HTTP_GET, .handler = index_handler, .user_ctx = NULL};
    if (httpd_register_uri_handler(camera_httpd, &index_uri) == ESP_OK) {
      Serial.println("âœ… æ³¨å†Œè·¯ç”±: /");
    } else {
      Serial.println("âŒ æ³¨å†Œè·¯ç”±å¤±è´¥: /");
    }
    
    httpd_uri_t capture_uri = {.uri = "/capture", .method = HTTP_GET, .handler = capture_handler, .user_ctx = NULL};
    if (httpd_register_uri_handler(camera_httpd, &capture_uri) == ESP_OK) {
      Serial.println("âœ… æ³¨å†Œè·¯ç”±: /capture");
    } else {
      Serial.println("âŒ æ³¨å†Œè·¯ç”±å¤±è´¥: /capture");
    }
    
    httpd_uri_t stream_uri = {.uri = "/stream", .method = HTTP_GET, .handler = stream_handler, .user_ctx = NULL};
    if (httpd_register_uri_handler(camera_httpd, &stream_uri) == ESP_OK) {
      Serial.println("âœ… æ³¨å†Œè·¯ç”±: /stream");
    } else {
      Serial.println("âŒ æ³¨å†Œè·¯ç”±å¤±è´¥: /stream");
    }
    
    httpd_uri_t mode_uri = {.uri = "/mode", .method = HTTP_GET, .handler = mode_handler, .user_ctx = NULL};
    if (httpd_register_uri_handler(camera_httpd, &mode_uri) == ESP_OK) {
      Serial.println("âœ… æ³¨å†Œè·¯ç”±: /mode");
    } else {
      Serial.println("âŒ æ³¨å†Œè·¯ç”±å¤±è´¥: /mode");
    }
    
    
    Serial.println("âœ… HTTPæœåŠ¡å™¨å’Œæ‰€æœ‰è·¯ç”±æ³¨å†Œå®Œæˆ");
    Serial.printf("ğŸ“Š HTTPæœåŠ¡å™¨ä¼˜åŒ–é…ç½®: ç«¯å£=%d, ä¼˜å…ˆçº§=%d, æ ˆå¤§å°=%d, è¿æ¥æ•°=%d\n", 
                  config.server_port, config.task_priority, config.stack_size, config.max_open_sockets);
  } else {
    Serial.println("âŒ HTTPæœåŠ¡å™¨å¯åŠ¨å¤±è´¥");
  }
}

//==================== æ–°å¢å¤šä»»åŠ¡ä»»åŠ¡å‡½æ•°å®šä¹‰ ====================
void ToFTask(void* parameter) {
  for(;;) {
    // ==== ToFé¿éšœä¼ æ„Ÿå™¨é‡‡é›†ä¸å¤„ç†é€»è¾‘è¿ç§» ====
    if (!tof_sensor_available) {
      vTaskDelay(20 / portTICK_PERIOD_MS);
      continue;
    }
    static int errorCount = 0;
    static unsigned long lastValidTime = 0;
    static float lastValidDistance = 0.0;
    // è¯»å–ä¼ æ„Ÿå™¨æ•°æ®
    tof_distance_mm = tof_sensor.read();
    tof_range_status = tof_sensor.ranging_data.range_status;
    // è½¬æ¢ä¸ºå˜ç±³
    float newDistance = tof_distance_mm / 10.0;
    // æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥ - æ”¾å®½æ¡ä»¶ï¼Œæ¥å—çŠ¶æ€0ã€1ã€2
    if ((tof_range_status == 0 || tof_range_status == 1 || tof_range_status == 2) && 
        newDistance >= 3.0 && newDistance <= 400.0) {
      tof_distance_cm = newDistance;
      currentAltitude = tof_distance_cm / 100.0; // cmè½¬ç±³ï¼Œä¿è¯å®šé«˜é€»è¾‘ç”¨åˆ°çš„é«˜åº¦æ•°æ®æ˜¯æœ€æ–°çš„
      lastValidDistance = newDistance;
      lastValidTime = millis();
      errorCount = 0;
      // æ›´æ–°éšœç¢ç‰©çŠ¶æ€
      if (newDistance <= obstacleThreshold) {
        obstacleDetected = true;
        obstacleWarning = false;
      } else if (newDistance <= warningThreshold) {
        obstacleDetected = false;
        obstacleWarning = true;
      } else {
        obstacleDetected = false;
        obstacleWarning = false;
      }
    } else {
      errorCount++;
      // å¦‚æœè¿ç»­é”™è¯¯è¶…è¿‡5æ¬¡ï¼Œé‡ç½®ä¼ æ„Ÿå™¨
      if (errorCount > 5) {
        Serial.printf("âš ï¸ VL53L1Xè¿ç»­é”™è¯¯è¿‡å¤š (%dæ¬¡), çŠ¶æ€=%d, è·ç¦»=%d mm\n", 
                      errorCount, tof_range_status, tof_distance_mm);
        tof_sensor.startContinuous(100);  // ä½¿ç”¨æ›´é•¿é—´éš”
        errorCount = 0;
      }
      // ä½¿ç”¨ä¸Šæ¬¡æœ‰æ•ˆæ•°æ® (å¦‚æœåœ¨5ç§’å†…)
      if (millis() - lastValidTime < 5000) {
        tof_distance_cm = lastValidDistance;
      } else {
        // è¶…è¿‡5ç§’æ²¡æœ‰æœ‰æ•ˆæ•°æ®ï¼Œè®¾ä¸ºå®‰å…¨è·ç¦»
        tof_distance_cm = 100.0;
        obstacleDetected = false;
        obstacleWarning = false;
      }
    }
    // è°ƒè¯•è¾“å‡º (æ¯10ç§’ä¸€æ¬¡)
    static unsigned long lastDebug = 0;
    if (millis() - lastDebug > 10000) {
      if (obstacle_avoidance_active) {
        Serial.printf("ğŸ“ ToFé¿éšœ: è·ç¦»=%.1fcm, çŠ¶æ€=%d, éšœç¢=%s, è­¦å‘Š=%s, é”™è¯¯=%d\n", 
                      tof_distance_cm, tof_range_status, 
                      obstacleDetected ? "æ˜¯" : "å¦", 
                      obstacleWarning ? "æ˜¯" : "å¦", 
                      errorCount);
      }
      lastDebug = millis();
    }
    vTaskDelay(20 / portTICK_PERIOD_MS); // 50Hz
  }
}


void ServoTask(void* parameter) {
  for(;;) {
    // ==== èˆµæœºåˆ†æ­¥åŠ¨ä½œçŠ¶æ€æœºé€»è¾‘ ====
    if (stop_motion) {
      Serial.printf("[ServoTask] stop_motionè§¦å‘ï¼Œå½“å‰æŒ‡ä»¤: %sï¼Œå›ä¸­ä½\n", cmdMap[current_direction]);
      stop_motion = false;
      motion_in_progress = false;
      current_direction = IDLE;
      servoState.direction = IDLE;
      servoState.in_progress = false;
      setServoIdle();
      vTaskDelay(10 / portTICK_PERIOD_MS);
      continue;
    }
    // æ£€æŸ¥æ˜¯å¦æœ‰æ–°åŠ¨ä½œ
    if (direction_changed) {
      Serial.printf("[ServoTask] direction_changedè§¦å‘: %s -> %s\n", cmdMap[current_direction], cmdMap[target_direction]);
      // ====== éé˜»å¡UPè¡¥å¿é€»è¾‘ ======
      if ((target_direction == FORWARD || target_direction == LEFT || target_direction == RIGHT)
          && altitudeHoldEnabled) {
        float delta = targetAltitude - currentAltitude;
        int maxN = 5, minN = 0;
        float maxDelta = 0.5; // æœ€å¤§è¡¥å¿åŒºé—´ï¼ˆå¦‚0.5mï¼‰
        int upCount = minN;
        if (delta > 0) {
          upCount = minN + (int)((maxN - minN) * (delta / maxDelta));
          if (upCount > maxN) upCount = maxN;
          if (upCount < minN) upCount = minN;
        }
        pendingUpCompensate = upCount;
        Serial.printf("[ServoTask] å¹³é¢åŠ¨ä½œåˆ‡æ¢ï¼ŒUPè¡¥å¿æ¬¡æ•°: %d (é«˜åº¦å·®: %.2f, ç›®æ ‡: %.2f, å½“å‰: %.2f)\n", upCount, delta, targetAltitude, currentAltitude);
      }
      // ====== éé˜»å¡UPè¡¥å¿é€»è¾‘ç»“æŸ ======
      direction_changed = false;
      current_direction = target_direction;
      servoState.direction = target_direction;
      servoState.Ind_var = 0;
      servoState.in_progress = (servoState.direction != IDLE);
      servoState.continuous = continuous_motion;
      servoState.last_step_time = millis();
      Serial.printf("[ServoTask] æ–°åŠ¨ä½œ: %s, continuous_motion=%d\n", cmdMap[servoState.direction], continuous_motion);

      // æ–°å¢ï¼šæ¯æ¬¡æ¨è¿›éƒ½æ‰“å°å½“å‰æŒ‡ä»¤
      Serial.printf("æ­£åœ¨æ‰§è¡Œ: %s\n", cmdMap[servoState.direction]);

      // æ–°å¢ï¼šåˆ‡æ¢æŒ‡ä»¤æ—¶ï¼Œå…ˆå¹³æ»‘è¿‡æ¸¡åˆ°æ–°åŠ¨ä½œèµ·å§‹è§’åº¦
      // è®¡ç®—æ–°åŠ¨ä½œçš„åˆå§‹è§’åº¦
      float angleL = mid_angle, angleR = mid_angle, angleLB = mid_angle, angleRB = mid_angle;
      switch (servoState.direction) {
        case FORWARD:
          angleL = 45 * sin(0 * PI / 180 - PI/2) + 135;
          angleR = 45 * sin(0 * PI / 180 + PI/2) + 45;
          angleLB = mid_angle;
          angleRB = mid_angle;
          break;
        case LEFT:
          angleL = mid_angle;
          angleR = 45 * sin(0 * PI / 180 + PI/2) + 45;
          angleLB = mid_angle;
          angleRB = mid_angle;
          break;
        case RIGHT:
          angleL = 45 * sin(0 * PI / 180 - PI/2) + 135;
          angleR = mid_angle;
          angleLB = mid_angle;
          angleRB = mid_angle;
          break;
        case UP:
          angleL = 45 * sin(0 * PI / 180 - PI/2) + 135;
          angleR = 45 * sin(0 * PI / 180 + PI/2) + 45;
          angleLB = min_angle;
          angleRB = max_angle;
          break;
        case DOWN:
          angleL = 45 * sin(0 * PI / 180 - PI/2) + 135;
          angleR = 45 * sin(0 * PI / 180 + PI/2) + 45;
          angleLB = max_angle;
          angleRB = min_angle;
          break;
        default:
          angleL = mid_angle;
          angleR = mid_angle;
          angleLB = mid_angle;
          angleRB = mid_angle;
          break;
      }
      // å¹³æ»‘è¿‡æ¸¡åˆ°æ–°åŠ¨ä½œèµ·å§‹è§’åº¦
      bool all_ready = false;
      while (!all_ready) {
        all_ready = true;
        sla_current = smoothMove(sla_current, angleL, servo_step);
        sra_current = smoothMove(sra_current, angleR, servo_step);
        slb_current = smoothMove(slb_current, angleLB, servo_step);
        srb_current = smoothMove(srb_current, angleRB, servo_step);
        sla.write(sla_current);
        sra.write(sra_current);
        slb.write(slb_current);
        srb.write(srb_current);
        if (sla_current != angleL || sra_current != angleR || slb_current != angleLB || srb_current != angleRB) {
          all_ready = false;
        }
        vTaskDelay(10 / portTICK_PERIOD_MS);
      }
      if (servoState.direction == IDLE) {
        setServoIdle();
        motion_in_progress = false;
      } else {
        motion_in_progress = true;
        Serial.printf("âš¡ å¼€å§‹æ‰§è¡Œ: %s\n", cmdMap[servoState.direction]);
      }
    }
    // æ²¡æœ‰åŠ¨ä½œåœ¨è¿›è¡Œ
    if (!servoState.in_progress || servoState.direction == IDLE) {
      vTaskDelay(10 / portTICK_PERIOD_MS);
      continue;
    }
    // åˆ†æ­¥æ¨è¿›åŠ¨ä½œ
    if (millis() - servoState.last_step_time >= 10) { // æ­¥è¿›é¢‘ç‡æ”¹ä¸º20msï¼Œå‡å°‘ç”µæºè´Ÿè½½
      float Ind_var = servoState.Ind_var;
      float interval_tims = servoState.interval_tims;
      int dir = servoState.direction;

      switch (dir) {
        case FORWARD:
        case LEFT:
        case RIGHT:
          servoState.interval_tims = 6.0;
          break;
        case DOWN:
          servoState.interval_tims = 6.0;
          break;
        case UP:
          servoState.interval_tims = 6.0;
          break;
        default:
          servoState.interval_tims = 6.0;
          break;
      }
      interval_tims = servoState.interval_tims;

      switch (dir) {
        case FORWARD: {
          float angleL = 45 * sin(Ind_var * PI / 180 - PI/2) + 135;
          float angleR = 45 * sin(Ind_var * PI / 180 + PI/2) + 45;
          float angleLB = mid_angle;
          float angleRB = mid_angle;
          if (isnan(angleL) || isinf(angleL)) angleL = mid_angle;
          if (isnan(angleR) || isinf(angleR)) angleR = mid_angle;
          // å¹³æ»‘æ’å€¼
          sla_current = smoothMove(sla_current, angleL, servo_step);
          sra_current = smoothMove(sra_current, angleR, servo_step);
          slb_current = smoothMove(slb_current, angleLB, servo_step);
          srb_current = smoothMove(srb_current, angleRB, servo_step);
          sla.write(sla_current);
          sra.write(sra_current);
          slb.write(slb_current);
          srb.write(srb_current);
          servoState.Ind_var += interval_tims;
          if (servoState.Ind_var > 360) {
            if (servoState.continuous) {
              servoState.Ind_var = 0;
            } else {
              servoState.in_progress = false;
              motion_in_progress = false;
              continuous_motion = false;
              // ä¸è¦é‡ç½®è§’åº¦ï¼Œä¸è¦ç›´æ¥å†™ä¸­ä½
              setServoIdle();
              Serial.printf("âœ… FORWARDåŠ¨ä½œå®Œæˆ\n");
            }
          }
          break;
        }
        case LEFT: {
          float angleL = mid_angle;
          float angleR = 45 * sin(Ind_var * PI / 180 + PI/2) + 45;
          float angleLB = mid_angle;
          float angleRB = mid_angle;
          if (isnan(angleR) || isinf(angleR)) angleR = mid_angle;
          sla_current = smoothMove(sla_current, angleL, servo_step);
          sra_current = smoothMove(sra_current, angleR, servo_step);
          slb_current = smoothMove(slb_current, angleLB, servo_step);
          srb_current = smoothMove(srb_current, angleRB, servo_step);
          sla.write(sla_current);
          sra.write(sra_current);
          slb.write(slb_current);
          srb.write(srb_current);
          servoState.Ind_var += interval_tims;
          if (servoState.Ind_var > 360) {
            if (servoState.continuous) {
              servoState.Ind_var = 0;
            } else {
              servoState.in_progress = false;
              motion_in_progress = false;
              continuous_motion = false;
              setServoIdle();
              Serial.printf("âœ… LEFTåŠ¨ä½œå®Œæˆ\n");
            }
          }
          break;
        }
        case RIGHT: {
          float angleL = 45 * sin(Ind_var * PI / 180 - PI/2) + 135;
          float angleR = mid_angle;
          float angleLB = mid_angle;
          float angleRB = mid_angle;
          if (isnan(angleL) || isinf(angleL)) angleL = mid_angle;
          sla_current = smoothMove(sla_current, angleL, servo_step);
          sra_current = smoothMove(sra_current, angleR, servo_step);
          slb_current = smoothMove(slb_current, angleLB, servo_step);
          srb_current = smoothMove(srb_current, angleRB, servo_step);
          sla.write(sla_current);
          sra.write(sra_current);
          slb.write(slb_current);
          srb.write(srb_current);
          servoState.Ind_var += interval_tims;
          if (servoState.Ind_var > 360) {
            if (servoState.continuous) {
              servoState.Ind_var = 0;
            } else {
              servoState.in_progress = false;
              motion_in_progress = false;
              continuous_motion = false;
              setServoIdle();
              Serial.printf("âœ… RIGHTåŠ¨ä½œå®Œæˆ\n");
            }
          }
          break;
        }
        case UP: {
          float angleL = 45 * sin(Ind_var * PI / 180 - PI/2) + 135;
          float angleR = 45 * sin(Ind_var * PI / 180 + PI/2) + 45;
          float angleLB = min_angle;
          float angleRB = max_angle;
          if (isnan(angleL) || isinf(angleL)) angleL = mid_angle;
          if (isnan(angleR) || isinf(angleR)) angleR = mid_angle;
          sla_current = smoothMove(sla_current, angleL, servo_step);
          sra_current = smoothMove(sra_current, angleR, servo_step);
          slb_current = smoothMove(slb_current, angleLB, servo_step);
          srb_current = smoothMove(srb_current, angleRB, servo_step);
          sla.write(sla_current);
          sra.write(sra_current);
          slb.write(slb_current);
          srb.write(srb_current);
          // å·²å½»åº•ç§»é™¤åŠ¨æ€é€Ÿåº¦è°ƒæ•´ä»£ç 
          servoState.Ind_var += interval_tims;
          if (servoState.Ind_var > 360) {
            if (servoState.continuous) {
              servoState.Ind_var = 0;
            } else {
              servoState.in_progress = false;
              motion_in_progress = false;
              continuous_motion = false;
              setServoIdle();
              Serial.printf("âœ… UPåŠ¨ä½œå®Œæˆ\n");
            }
          }
          break;
        }
        case DOWN: {
          float angleL = 45 * sin(Ind_var * PI / 180 - PI/2) + 135;
          float angleR = 45 * sin(Ind_var * PI / 180 + PI/2) + 45;
          float angleLB = max_angle;
          float angleRB = min_angle;
          if (isnan(angleL) || isinf(angleL)) angleL = mid_angle;
          if (isnan(angleR) || isinf(angleR)) angleR = mid_angle;
          sla_current = smoothMove(sla_current, angleL, servo_step);
          sra_current = smoothMove(sra_current, angleR, servo_step);
          slb_current = smoothMove(slb_current, angleLB, servo_step);
          srb_current = smoothMove(srb_current, angleRB, servo_step);
          sla.write(sla_current);
          sra.write(sra_current);
          slb.write(slb_current);
          srb.write(srb_current);
          // å·²å½»åº•ç§»é™¤åŠ¨æ€é€Ÿåº¦è°ƒæ•´ä»£ç 
          servoState.Ind_var += interval_tims;
          if (servoState.Ind_var > 360) {
            if (servoState.continuous) {
              servoState.Ind_var = 0;
            } else {
              servoState.in_progress = false;
              motion_in_progress = false;
              continuous_motion = false;
              setServoIdle();
              Serial.printf("âœ… DOWNåŠ¨ä½œå®Œæˆ\n");
            }
          }
          break;
        }
        // å…¶å®ƒåŠ¨ä½œå¯æŒ‰éœ€è¡¥å……
      }
      servoState.last_step_time = millis();
    }
    // ä¸»å¾ªç¯ä¼˜å…ˆå¤„ç†UPè¡¥å¿
    if (pendingUpCompensate > 0) {
      if (!servoState.in_progress) {
        servoState.direction = UP;
        servoState.Ind_var = 0;
        servoState.in_progress = true;
        servoState.continuous = false;
        pendingUpCompensate--;
        Serial.printf("[ServoTask] æ‰§è¡ŒUPè¡¥å¿ï¼Œå‰©ä½™: %d\n", pendingUpCompensate);
      }
      // è¡¥å¿æœªå®Œæˆå‰ä¸åˆ‡æ¢åˆ°ç›®æ ‡åŠ¨ä½œ
      vTaskDelay(2 / portTICK_PERIOD_MS);
      continue;
    }
    vTaskDelay(2 / portTICK_PERIOD_MS); // é«˜é€Ÿå“åº”
  }
}
void LEDTask(void* parameter) {
  for(;;) {
    // ==== LEDæ•ˆæœæ›´æ–°é€»è¾‘è¿ç§» ====
    static unsigned long last_debug = 0;
    bool debug_output = (millis() - last_debug > 10000);
    if (debug_output) {
      Serial.printf("ğŸŒˆ LEDæ›´æ–°: å¯ç”¨=%s, æ¨¡å¼=%d\n", led_enabled ? "æ˜¯" : "å¦", current_led_mode);
      last_debug = millis();
    }
    if (!led_enabled) {
      FastLED.clear();
      FastLED.show();
      vTaskDelay(50 / portTICK_PERIOD_MS);
      continue;
    }
    switch (current_led_mode) {
      case LED_BREATH:
        updateBreathEffect();
        if (debug_output) {
          Serial.printf("ğŸ« å‘¼å¸ç¯æ¨¡å¼: é¢œè‰²=(%d,%d,%d), å…¨å±€äº®åº¦=%d\n", 
                        leds[0].r, leds[0].g, leds[0].b, FastLED.getBrightness());
        }
        break;
      case LED_RAINBOW:
        updateRainbowEffect();
        if (debug_output) {
          Serial.printf("ğŸŒˆ å½©è™¹æ¨¡å¼: è‰²ç›¸=%d, LED0=(%d,%d,%d)\n", 
                        rainbow_hue, leds[0].r, leds[0].g, leds[0].b);
        }
        FastLED.show();
        break;
      case LED_SOLID:
        updateSolidColor();
        if (debug_output) {
          Serial.printf("ğŸ’¡ å›ºå®šé¢œè‰²: (%d,%d,%d)\n", leds[0].r, leds[0].g, leds[0].b);
        }
        FastLED.show();
        break;
      case LED_OFF:
        FastLED.clear();
        FastLED.setBrightness(0);
        if (debug_output) {
          Serial.println("âš« LEDå…³é—­æ¨¡å¼");
        }
        FastLED.show();
        break;
    }
    if (debug_output) {
      Serial.printf("âœ… FastLEDå¤„ç†å®Œæˆ (æ¨¡å¼=%d)\n", current_led_mode);
    }
    vTaskDelay(50 / portTICK_PERIOD_MS); // 20Hz
  }
}
void FlightControlTask(void* parameter) {
  for(;;) {
    unsigned long current_time = millis();
    // åªä¿ç•™å®šé«˜æ§åˆ¶å’Œå·¡èˆªé€»è¾‘
    if (altitudeHoldEnabled && tof_sensor_available) {
      static unsigned long lastAltitudeControl = 0;
      if (current_time - lastAltitudeControl >= altitudeControlInterval) {
        int altitude_command = calculateAltitudeControl();
        Serial.printf("[FlightControlTask] é«˜åº¦: %.2f, å½“å‰æŒ‡ä»¤: %s, è®¡ç®—ç»“æœ: %s\n", currentAltitude, cmdMap[current_direction], cmdMap[altitude_command]);
        if (altitude_command != IDLE && altitude_command != current_direction) {
          target_direction = altitude_command;
          direction_changed = true;
          continuous_motion = true;
          Serial.printf("[FlightControlTask] åˆ‡æ¢ç›®æ ‡æŒ‡ä»¤: %s -> %s\n", cmdMap[current_direction], cmdMap[altitude_command]);
        } else if (current_direction == UP && altitude_command == IDLE) {
          target_direction = IDLE;
          direction_changed = true;
          continuous_motion = false;
          stop_motion = true;
          Serial.println("[FlightControlTask] ğŸ›‘ é«˜åº¦è¾¾æ ‡ï¼Œåœæ­¢UPåŠ¨ä½œ (stop_motion = true)");
        }
        lastAltitudeControl = current_time;
      }
    }
    if (flight_mode == CRUISE_MODE) {
      static unsigned long last_cruise_time = 0;
      if (current_time - last_cruise_time >= cruise_interval) {
        int random_directions[] = {FORWARD, LEFT, RIGHT};
        int random_dir = random(3);
        int cruise_command = random_directions[random_dir];
        if ((!altitudeHoldEnabled || calculateAltitudeControl() == IDLE)) {
          target_direction = cruise_command;
          direction_changed = true;
          continuous_motion = true;
          Serial.printf("[FlightControlTask] ğŸ² éšæœºå·¡èˆª: æ–¹å‘=%s\n", cmdMap[cruise_command]);
        }
        last_cruise_time = current_time;
      }
    }
    vTaskDelay(20 / portTICK_PERIOD_MS); // 50Hz
  }
}
//==================== End ====================


// ========== æ–°å¢ï¼šæ ¹æ®é«˜åº¦è¯¯å·®åŠ¨æ€è°ƒæ•´èˆµæœºé€Ÿåº¦ ===========
float getUpIntervalTims() {
  float min_tims = 1.0; // æœ€æ…¢ï¼ˆé è¿‘1.5mï¼‰
  float max_tims = 8.0; // æœ€å¿«ï¼ˆè¿œç¦»1.5mï¼‰
  float low = 0.5, high = 0.7;
  if (currentAltitude < low) return max_tims;
  if (currentAltitude >= high) return min_tims;
  float ratio = (high - currentAltitude) / (high - low); // 1~0
  return min_tims + (max_tims - min_tims) * ratio;
}

float getDownIntervalTims() {
  float min_tims = 1.0; // æœ€æ…¢ï¼ˆé è¿‘1.8mï¼‰
  float max_tims = 8.0; // æœ€å¿«ï¼ˆè¿œç¦»1.8mï¼‰
  float low = 1.8, high = 2.0;
  if (currentAltitude > high) return max_tims;
  if (currentAltitude <= low) return min_tims;
  float ratio = (currentAltitude - low) / (high - low); // 0~1
  return min_tims + (max_tims - min_tims) * (1 - ratio);
}
