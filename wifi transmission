/*
 * Shitbro ESP32â€‘S3 Dual Stream â€” 30 FPS Patch
 * -------------------------------------------------
 * âœ… ç›®æ ‡ï¼š30FPSï¼ˆQVGAç¨³å®šï¼‰/ VGAè‡ªé€‚åº”ï¼ŒWiFiä¼ è¾“æ›´æµç•…
 * âœ… æ ¸å¿ƒæ”¹åŠ¨ï¼š
 *   1. WiFiå…³é—­çœç”µ & 40MHz å¸¦å®½
 *   2. æ‘„åƒå¤´å‚æ•°ï¼šGRAB_LATEST + fb_count=3 + 24MHz XCLK
 *   3. é‡‡é›† & å‘é€è§£è€¦ï¼šCameraTask / StreamTask + é˜Ÿåˆ—ï¼ˆä¸¢æ—§ä¿æ–°ï¼‰
 *   4. WebSocket äºŒè¿›åˆ¶ä¼  JPEGï¼ˆå¯é€‰ï¼‰ï¼Œæˆ– MJPEG HTTP æ”¹ä¸ºéé˜»å¡
 *   5. ç§»é™¤é¢‘ç¹ Serial/ delayï¼Œå‡å°‘é˜»å¡
 *
 * ğŸ‘‡ è¿™æ˜¯ä¸€ä¸ªå¯ç›´æ¥æ›¿æ¢çš„å•æ–‡ä»¶ï¼ˆArduino .ino æˆ– main.cppï¼‰ã€‚
 * å¦‚æœä½ æƒ³ç»§ç»­æ‹†åˆ†ï¼Œè¯·æŠŠä»»åŠ¡ã€HTMLã€èˆµæœºé€»è¾‘æ‹†åˆ°ç‹¬ç«‹ .h/.cpp ä¸­ã€‚
 */

/****************************************************
 * 1. å¤´æ–‡ä»¶ & å…¨å±€é…ç½®
 ****************************************************/ 
#include <Arduino.h>
#include <WiFi.h>
#include <esp_wifi.h>
#include <esp_camera.h>
#include <esp_http_server.h>
#include <WebSocketsServer.h>
#include <ESP32Servo.h>
#include "freertos/queue.h"
#include "freertos/task.h"

/****************** ä½ çš„åŸå§‹åŠŸèƒ½é€‰æ‹© *****************/
#define ENABLE_HTTP_STREAM   1        // ä¿ç•™ HTTP MJPEG
#define ENABLE_WS_STREAM     1        // å¯ç”¨ WebSocket äºŒè¿›åˆ¶ JPEG
#define TARGET_FPS           30       // æœŸæœ›FPSï¼ˆä»…ç”¨äºå‘é€èŠ‚æµï¼‰
#define MAX_CLIENTS          2        // åŒæ—¶è§‚çœ‹çš„å®¢æˆ·ç«¯æ•°é‡
#define DEBUG_LOG            0        // å…³é—­å¤§é‡ä¸²å£æ‰“å°ï¼ˆ1=å¼€ï¼‰

/****************** WiFi é…ç½® *****************/
#define WIFI_SSID "hupan1"
#define WIFI_PASS ""
#define WIFI_TIMEOUT 30000

/****************** èˆµæœºå®šä¹‰ï¼ˆä¿ç•™ä½ çš„ï¼‰ *****************/
#define IDLE     0
#define FORWARD  1
#define UP       2
#define DOWN     3
#define LEFT     4
#define RIGHT    5
#define BACKWARD 6
#define LWAVE    7
#define RWAVE    8

Servo sla, slb, sra, srb;  // æ²¡æ”¹
int min_angle = 0, mid_angle = 90, max_angle = 180;
float sla_current=90, slb_current=90, sra_current=90, srb_current=90;
const float servo_step = 5.0;
volatile int current_direction = IDLE;
volatile int target_direction  = IDLE;
volatile bool direction_changed = false;
volatile bool stop_motion = false;
volatile bool continuous_motion = false;
const char* cmdMap[] = {"IDLE","FWD","UP","DOWN","LEFT","RIGHT","BACK","LWAVE","RWAVE","TRACK","CRUISE","MANUAL"};
const int CMD_COUNT = 12;

/****************** å…¨å±€å˜é‡ *****************/
static httpd_handle_t camera_httpd = NULL;      // HTTP server handle
WebSocketsServer webSocket(81);                 // WebSocket server
volatile bool websocket_connected = false;

String device_ip = "";

// æ‘„åƒå¤´å¸§é˜Ÿåˆ—ï¼ˆé‡‡é›†â†’å‘é€ï¼‰
static QueueHandle_t frameQ = nullptr;          // å­˜ camera_fb_t* æŒ‡é’ˆ

// ç»Ÿè®¡å‘é€è€—æ—¶åšè‡ªé€‚åº”
static uint32_t avg_send_ms = 0;

/****************************************************
 * 2. è°ƒå‚å‡½æ•°
 ****************************************************/
static inline void tuneWiFi() {
  WiFi.setSleep(false);
  esp_wifi_set_ps(WIFI_PS_NONE);
  esp_wifi_set_protocol(WIFI_IF_STA, WIFI_PROTOCOL_11B | WIFI_PROTOCOL_11G | WIFI_PROTOCOL_11N);
  esp_wifi_set_bandwidth(WIFI_IF_STA, WIFI_BW_HT40);
  esp_wifi_set_max_tx_power(78); // 19.5dBm
}

/****************************************************
 * 3. æ‘„åƒå¤´é…ç½®
 ****************************************************/
static camera_config_t cam_cfg = {
  .pin_pwdn  = -1, .pin_reset = -1,
  .pin_xclk  = 10,
  .pin_sscb_sda = 40, .pin_sscb_scl = 39,
  .pin_d7 = 48, .pin_d6 = 11, .pin_d5 = 12, .pin_d4 = 14,
  .pin_d3 = 16, .pin_d2 = 18, .pin_d1 = 17, .pin_d0 = 15,
  .pin_vsync = 38, .pin_href = 47, .pin_pclk = 13,
  .xclk_freq_hz = 24000000,              // â†— 24MHz
  .ledc_timer   = LEDC_TIMER_0,
  .ledc_channel = LEDC_CHANNEL_0,
  .pixel_format = PIXFORMAT_JPEG,
  .frame_size   = FRAMESIZE_QVGA,        // ä» QVGA èµ·æ­¥ï¼Œåç»­å¯è‡ªé€‚åº”
  .jpeg_quality = 12,
  .fb_count     = 3,                     // å¤šå¸§ç¼“å†²
  .fb_location  = CAMERA_FB_IN_PSRAM,
  .grab_mode    = CAMERA_GRAB_LATEST     // ä¸¢æ—§ä¿æ–°
};

bool initCamera() {
  if(DEBUG_LOG) Serial.println("[CAM] Init...");
  esp_err_t err = esp_camera_init(&cam_cfg);
  if(err != ESP_OK){
    Serial.printf("[CAM] Init failed 0x%x\n", err);
    return false;
  }
sensor_t *s = esp_camera_sensor_get();
  if(s){
    s->set_vflip(s, 1);
    s->set_hmirror(s, 0);
  }
  if(DEBUG_LOG) Serial.println("[CAM] OK");
  return true;
}

/****************************************************
 * 4. WiFi è¿æ¥
 ****************************************************/
bool connectWiFi(){
  if(DEBUG_LOG) Serial.printf("[WiFi] Connecting to %s...\n", WIFI_SSID);
  WiFi.mode(WIFI_STA);
  WiFi.disconnect(true);
  delay(500);
  WiFi.begin(WIFI_SSID, WIFI_PASS);

  unsigned long start = millis();
  while(WiFi.status() != WL_CONNECTED && millis() - start < WIFI_TIMEOUT){
    delay(200);
    if(DEBUG_LOG) Serial.print(".");
  }
  if(WiFi.status() == WL_CONNECTED){
    device_ip = WiFi.localIP().toString();
    if(DEBUG_LOG) Serial.printf("\n[WiFi] OK IP=%s RSSI=%d\n", device_ip.c_str(), WiFi.RSSI());
    return true;	
  }
  Serial.println("\n[WiFi] FAILED");
  return false;
}

void checkWiFiConnection(){
  static unsigned long last = 0;
  static bool was = false;
  if(millis() - last > 30000){
    bool now = WiFi.status()==WL_CONNECTED;
    if(now && !was){
      device_ip = WiFi.localIP().toString();
      Serial.printf("[WiFi] Reconnected %s\n", device_ip.c_str());
    } else if(!now && was){
      Serial.println("[WiFi] Lost, reconnecting...");
      WiFi.reconnect();
    }
    was = now;
    last = millis();
  }
}

/****************************************************
 * 5. WebSocket
 ****************************************************/
void processCommand(String command); // å‰ç½®å£°æ˜

void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length){
  switch(type){
    case WStype_DISCONNECTED:
      if(DEBUG_LOG) Serial.printf("[WS] #%u disconnected\n", num);
      websocket_connected = false;
      break;
    case WStype_CONNECTED:{
      IPAddress ip = webSocket.remoteIP(num);
      if(DEBUG_LOG) Serial.printf("[WS] #%u connected from %s\n", num, ip.toString().c_str());
      websocket_connected = true;
      String status = "{\"type\":\"status\",\"connected\":true}";
      webSocket.sendTXT(num, status);
      break;}
    case WStype_TEXT:{
      String cmd = String((char*)payload, length);
      if(DEBUG_LOG) Serial.printf("[WS] cmd: %s\n", cmd.c_str());
      processCommand(cmd);
      String rsp = "{\"type\":\"response\",\"command\":\"" + cmd + "\",\"status\":\"ok\"}";
      webSocket.sendTXT(num, rsp);
      break;}
    default: break;
  }
}

void initWebSocket(){
  webSocket.begin();
  webSocket.onEvent(webSocketEvent);
  if(DEBUG_LOG) Serial.println("[WS] Server on :81");
}

/****************************************************
 * 6. MJPEG HTTP æµå¤„ç†ï¼ˆç®€åŒ–ç‰ˆï¼‰
 ****************************************************/
#if ENABLE_HTTP_STREAM
#define PART_BOUNDARY "123456789000000000000987654321"
static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" PART_BOUNDARY;
static const char* _STREAM_BOUNDARY     = "\r\n--" PART_BOUNDARY "\r\n";
static const char* _STREAM_PART         = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

// æˆ‘ä»¬ä¸åœ¨ handler é‡ŒæŠ“å¸§ï¼Œè€Œæ˜¯ä»é˜Ÿåˆ—å–å¸§
static esp_err_t stream_handler(httpd_req_t *req){
  esp_err_t res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if(res != ESP_OK) return res;
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  httpd_resp_set_hdr(req, "Cache-Control", "no-cache");

  camera_fb_t *fb = nullptr;
  char part_buf[64];
  TickType_t lastSend = xTaskGetTickCount();

  while(true){
    // æ¯å¸§ä»é˜Ÿåˆ—å–
    if(xQueueReceive(frameQ, &fb, pdMS_TO_TICKS(2000)) != pdTRUE){
      // è¶…æ—¶ï¼Œå¯èƒ½æ— å¸§ï¼Œç»§ç»­
      continue;
    }
    if(!fb){
      continue;
    }
    // è¾¹ç•Œ
    res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    if(res != ESP_OK) break;

    size_t hlen = snprintf(part_buf, sizeof(part_buf), _STREAM_PART, fb->len);
    res = httpd_resp_send_chunk(req, part_buf, hlen);
    if(res != ESP_OK) break;

    res = httpd_resp_send_chunk(req, (const char*)fb->buf, fb->len);

    esp_camera_fb_return(fb);
    fb = nullptr;
    if(res != ESP_OK) break;

    // ç®€å•èŠ‚æµï¼šç¡®ä¿ä¸è¶…è¿‡ TARGET_FPS
    uint32_t frame_interval_ms = 1000 / TARGET_FPS;
    uint32_t elapsed = (xTaskGetTickCount() - lastSend) * portTICK_PERIOD_MS;
    if(elapsed < frame_interval_ms){
      vTaskDelay(pdMS_TO_TICKS(frame_interval_ms - elapsed));
    }
    lastSend = xTaskGetTickCount();
  }
  httpd_resp_send_chunk(req, NULL, 0);
  return res;
}
#endif

static esp_err_t index_handler(httpd_req_t *req){
  const char *html = "<!DOCTYPE html><html><head><meta charset='utf-8'><title>Skyris</title></head><body>"
                     "<h2>Skyris Stream</h2>"
#if ENABLE_HTTP_STREAM
                     "<img src='/stream' style='max-width:100%'>"
#endif
                     "<script>\n"
                     "let ws=new WebSocket('ws://'+location.hostname+':81');\n"
                     "ws.binaryType='arraybuffer';\n"
                     "ws.onmessage=e=>{if(e.data instanceof ArrayBuffer){let blob=new Blob([e.data],{type:'image/jpeg'});document.getElementById('wsimg').src=URL.createObjectURL(blob);}else console.log(e.data);};\n"
                     "function send(c){ws.send(c);}\n"
                     "</script>"
                     "<h3>WS Stream</h3><img id='wsimg' style='max-width:100%'><br>"
                     "<button onclick=send('FWD')>FWD</button> <button onclick=send('IDLE')>STOP</button>"
                     "</body></html>";
  httpd_resp_set_type(req, "text/html");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  return httpd_resp_send(req, html, strlen(html));
}

static esp_err_t capture_handler(httpd_req_t *req){
  camera_fb_t *fb = esp_camera_fb_get();
  if(!fb){
    httpd_resp_send_500(req); return ESP_FAIL;
  }
  httpd_resp_set_type(req, "image/jpeg");
  httpd_resp_set_hdr(req, "Content-Disposition", "inline; filename=capture.jpg");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  esp_err_t res = httpd_resp_send(req, (const char*)fb->buf, fb->len);
  esp_camera_fb_return(fb);
  return res;
}

static esp_err_t mode_handler(httpd_req_t *req){
  size_t len = httpd_req_get_url_query_len(req) + 1;
  if(len > 1){
    char *buf = (char*)malloc(len);
    if(httpd_req_get_url_query_str(req, buf, len) == ESP_OK){
      char param[32];
      if(httpd_query_key_value(buf, "mode", param, sizeof(param)) == ESP_OK){
        String m = param; m.toUpperCase();
        processCommand(m);
      }
    }
    free(buf);
  }
  httpd_resp_set_type(req, "text/plain");
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
  return httpd_resp_send(req, "OK", 2);
}

void startCameraServer(){
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 80;
  config.max_uri_handlers = 8;
  config.stack_size = 16384;           // å¢å¤§æ ˆ
  config.task_priority = 5;
  config.core_id = 0;
  config.max_open_sockets = 4;
  config.lru_purge_enable = true;

  if(httpd_start(&camera_httpd, &config) == ESP_OK){
    httpd_uri_t index_uri   = { .uri="/",       .method=HTTP_GET, .handler=index_handler,   .user_ctx=NULL };
#if ENABLE_HTTP_STREAM
    httpd_uri_t stream_uri  = { .uri="/stream", .method=HTTP_GET, .handler=stream_handler,  .user_ctx=NULL };
#endif
    httpd_uri_t capture_uri = { .uri="/capture",.method=HTTP_GET, .handler=capture_handler, .user_ctx=NULL };
    httpd_uri_t mode_uri    = { .uri="/mode",   .method=HTTP_GET, .handler=mode_handler,    .user_ctx=NULL };
    httpd_register_uri_handler(camera_httpd,&index_uri);
#if ENABLE_HTTP_STREAM
    httpd_register_uri_handler(camera_httpd,&stream_uri);
#endif
    httpd_register_uri_handler(camera_httpd,&capture_uri);
    httpd_register_uri_handler(camera_httpd,&mode_uri);
  } else {
    Serial.println("[HTTP] start failed");
  }
}

/****************************************************
 * 7. ä»»åŠ¡ï¼šCameraTask / StreamTask
 ****************************************************/
// CameraTask ä¸åœæŠ“å¸§æ”¾å…¥é˜Ÿåˆ—
void CameraTask(void *param){
  for(;;){
    camera_fb_t *fb = esp_camera_fb_get();
    if(!fb){
      vTaskDelay(1);
      continue;
    }
    if(xQueueSend(frameQ, &fb, 0) != pdTRUE){
      esp_camera_fb_return(fb); // é˜Ÿåˆ—æ»¡ï¼Œä¸¢å¸§
    }
  }
}

#if ENABLE_WS_STREAM
// WebSocket äºŒè¿›åˆ¶æ¨æµä»»åŠ¡
void WsStreamTask(void *param){
  TickType_t lastSend = xTaskGetTickCount();
  camera_fb_t *fb = nullptr;
  for(;;){
    if(xQueueReceive(frameQ, &fb, portMAX_DELAY) == pdTRUE){
      if(websocket_connected){
        webSocket.broadcastBIN(fb->buf, fb->len);
      }
      esp_camera_fb_return(fb);
      fb = nullptr;
      // ç®€å•èŠ‚æµ
      uint32_t frame_interval_ms = 1000 / TARGET_FPS;
      uint32_t elapsed = (xTaskGetTickCount() - lastSend) * portTICK_PERIOD_MS;
      if(elapsed < frame_interval_ms){
        vTaskDelay(pdMS_TO_TICKS(frame_interval_ms - elapsed));
      }
      lastSend = xTaskGetTickCount();
    }
  }
}
#endif

/****************************************************
 * 8. èˆµæœº/æŒ‡ä»¤å¤„ç†ï¼ˆä¿ç•™åŸé€»è¾‘ï¼Œç•¥åšç²¾ç®€ï¼‰
 ****************************************************/
float smoothMove(float current, float target, float step){
  if (fabs(target-current) <= step) return target;
  return current + (target>current? step : -step);
}

void setServoIdle(){
  bool done=false;
  while(!done){
    done=true;
    sla_current = smoothMove(sla_current, mid_angle, servo_step);
    slb_current = smoothMove(slb_current, mid_angle, servo_step);
    sra_current = smoothMove(sra_current, mid_angle, servo_step);
    srb_current = smoothMove(srb_current, mid_angle, servo_step);
    sla.write(sla_current); slb.write(slb_current); sra.write(sra_current); srb.write(srb_current);
    if(sla_current!=mid_angle||slb_current!=mid_angle||sra_current!=mid_angle||srb_current!=mid_angle) done=false;
    vTaskDelay(10/portTICK_PERIOD_MS);
  }
}

void servo_attach(){
  sla.attach(3,1000,2000); sla.write(mid_angle);
  slb.attach(4,1000,2000); slb.write(mid_angle);
  sra.attach(7,1000,2000); sra.write(mid_angle);
  srb.attach(8,1000,2000); srb.write(mid_angle);
}

void forceStopMotion(){
  stop_motion = true;
  current_direction = target_direction = IDLE;
  setServoIdle();
}

// è¿™é‡Œåªåšç¤ºä¾‹ï¼Œåªä¿ç•™æ–¹å‘å‘½ä»¤å¤„ç†
void processCommand(String command){
  command.trim(); command.toUpperCase();
  int idx = -1;
  for(int i=0;i<CMD_COUNT;i++) if(command.equals(cmdMap[i])){ idx=i; break; }
  if(idx==-1){ if(DEBUG_LOG) Serial.printf("[CMD] unknown %s\n", command.c_str()); return; }
  if(idx == IDLE){ forceStopMotion(); return; }
  // å…¶å®ƒæ–¹å‘å‘½ä»¤ï¼šè¿™é‡Œåªæ¼”ç¤ºç›´æ¥èµ‹å€¼ï¼ˆä½ åŸæ¥çš„çŠ¶æ€æœºå¯ç»§ç»­ä¿ç•™ï¼‰
  target_direction = idx;
  direction_changed = true;
  continuous_motion = true;
}

// ä½ çš„ ServoTask ä¹Ÿå¯ä»¥ä¿ç•™ï¼ˆç•¥ï¼‰
void ServoTask(void* parameter){
  for(;;){
    if(stop_motion){ stop_motion=false; setServoIdle(); vTaskDelay(10); continue; }
    if(direction_changed){ direction_changed=false; current_direction=target_direction; /*ç•¥*/ }
    // TODO: æŒ‰ä½ åŸæœ¬çš„åˆ†æ­¥é€»è¾‘å†™
    vTaskDelay(5);
  }
}

/****************************************************
 * 9. setup()/loop()
 ****************************************************/
void setup(){
  Serial.begin(115200);
  delay(300);
  Serial.println("[BOOT] Skyris 30FPS Patch");

  // PSRAM check
  if(!psramFound()){
    Serial.println("[PSRAM] Not found. downgrade settings");
    cam_cfg.fb_location = CAMERA_FB_IN_DRAM;
    cam_cfg.frame_size  = FRAMESIZE_VGA;
    cam_cfg.jpeg_quality= 15;
  }

  if(!connectWiFi()){
    Serial.println("[BOOT] WiFi failed, offline mode");
  } else {
    tuneWiFi();
  }

  // Camera
  if(!initCamera()){
    Serial.println("[BOOT] Camera init failed");
  }

  // HTTP + WS
  if(WiFi.status()==WL_CONNECTED){
    startCameraServer();
    initWebSocket();
  }

  // èˆµæœº
  servo_attach();

  // é˜Ÿåˆ— & ä»»åŠ¡
  frameQ = xQueueCreate(2, sizeof(camera_fb_t*));
  xTaskCreatePinnedToCore(CameraTask, "CameraTask", 4096, NULL, 6, NULL, 1);
#if ENABLE_WS_STREAM
  xTaskCreatePinnedToCore(WsStreamTask,"WsStream",  6144, NULL, 5, NULL, 0);
#endif
  xTaskCreatePinnedToCore(ServoTask,  "ServoTask",  4096, NULL, 4, NULL, 1);

  Serial.printf("[BOOT] Ready. IP=%s\n", device_ip.c_str());
}

void loop(){
  webSocket.loop();       // WS éœ€è¦åœ¨ loop é‡Œå¤„ç†äº‹ä»¶
  checkWiFiConnection();
  static unsigned long lastStatus = 0;
  if(millis()-lastStatus>1000){
    String status = "{\"type\":\"status\",\"main_mode\":\"MANUAL\"}";
    webSocket.broadcastTXT(status);
    lastStatus = millis();
  }
  vTaskDelay(10 / portTICK_PERIOD_MS);
}
